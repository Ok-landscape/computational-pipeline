# Social Media Posts: The Residue Theorem in Complex Analysis

## SHORT-FORM POSTS

### Twitter/X (280 chars)
The Residue Theorem transforms complex integrals into simple sums! ∮f(z)dz = 2πi·∑Res(f,zₖ). Used it to prove ∫₀^∞ 1/(x²+1)dx = π/2 with just one residue calculation. #ComplexAnalysis #Math #Python

---

### Bluesky (300 chars)
Just implemented the Residue Theorem in Python. This elegant result: ∮f(z)dz = 2πi·∑Res(f,zₖ) lets you evaluate difficult contour integrals by computing residues at poles. Verified ∫₀^∞ 1/(x²+1)dx = π/2 numerically. Complex analysis is beautiful.

---

### Threads (500 chars)
Complex analysis has this magical result called the Residue Theorem. Instead of computing difficult contour integrals directly, you just find the "residues" at singularities inside your contour.

Formula: ∮f(z)dz = 2πi × (sum of residues)

Built a Python notebook demonstrating this with f(z) = 1/(z²+1). The poles at z = i and z = -i have residues 1/(2i) and -1/(2i).

Best part? Used it to evaluate the real integral ∫₀^∞ 1/(x²+1)dx = π/2. Mind-blowing connection!

---

### Mastodon (500 chars)
Implemented the Residue Theorem in Python with numerical verification.

Key result: ∮_C f(z)dz = 2πi·∑Res(f, zₖ)

For f(z) = 1/(z²+1) with poles at z = ±i:
• Res(f, i) = 1/(2i)
• Res(f, -i) = -1/(2i)

The real power: evaluating ∫₀^∞ 1/(x²+1)dx = π/2 via semicircular contour enclosing only z = i.

Also demonstrated higher-order poles: for g(z) = z/(z-1)², the residue requires differentiation.

Numerical and theoretical results match perfectly.

#ComplexAnalysis #Mathematics #Python #Science

---

## LONG-FORM POSTS

### Reddit (r/learnpython or r/math)

**Title:** I implemented the Residue Theorem in Python - here's how it transforms impossible integrals into simple calculations

**Body:**

Hey everyone!

I just finished a notebook exploring the Residue Theorem from complex analysis, and I wanted to share what I learned because it genuinely blew my mind.

**What is the Residue Theorem?**

In simple terms: instead of computing a contour integral around a closed loop in the complex plane directly (which can be hard), you just find the "residues" at the singularities inside that loop and add them up.

The formula: ∮f(z)dz = 2πi × (sum of all residues inside the contour)

**ELI5 version:** Imagine you're walking around a lake and want to measure something about the water. Instead of measuring the whole perimeter, you only need to check certain "special points" (poles) inside the lake. The global information (the integral) is determined entirely by local information (the residues).

**What I implemented:**

1. Computed residues at simple poles for f(z) = 1/(z²+1)
   - Pole at z = i has residue 1/(2i)
   - Pole at z = -i has residue -1/(2i)

2. Verified contour integrals numerically match the theorem prediction

3. The coolest part: evaluated the real integral ∫₀^∞ 1/(x²+1)dx = π/2 by using a semicircular contour that only encloses z = i

4. Also handled double poles using the derivative formula

**Key takeaway:** The Residue Theorem connects local behavior (what happens at singularities) to global properties (the value of the integral). This is why it's so powerful for solving real-world integrals in physics and engineering.

Check out the full interactive notebook here: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/residue_theorem.ipynb

Happy to answer questions!

---

### Facebook (500 chars)

Ever wondered how mathematicians solve "impossible" integrals?

There's a beautiful result called the Residue Theorem that turns complex contour integrals into simple addition!

Instead of integrating around a curve, you find special values called "residues" at singular points and sum them up. The formula: ∮f(z)dz = 2πi × ∑(residues)

I used Python to verify this works perfectly. The coolest application? Solving ∫₀^∞ 1/(x²+1)dx = π/2 with just one calculation!

Full notebook: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/residue_theorem.ipynb

---

### LinkedIn (1000 chars)

Just completed a computational deep-dive into one of the most elegant results in mathematics: the Residue Theorem.

**Technical Summary:**

The Residue Theorem states that for a function f(z) analytic inside a closed contour C except at isolated singularities:

∮_C f(z)dz = 2πi·∑Res(f, zₖ)

This transforms the global problem of contour integration into local calculations at singular points.

**Implementation Highlights:**

• Computed residues for simple poles using limit formulas
• Implemented numerical contour integration for verification
• Demonstrated higher-order pole residue calculation via differentiation
• Applied the theorem to evaluate real definite integrals

**Key Application:**

The integral ∫₀^∞ 1/(x²+1)dx = π/2 was computed by extending to a semicircular contour in the complex plane and using just one residue at z = i.

**Skills Demonstrated:**
- Complex analysis fundamentals
- Numerical methods (contour integration, numerical differentiation)
- Scientific visualization with matplotlib
- Python (NumPy, SciPy)

View the full interactive notebook: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/residue_theorem.ipynb

#Mathematics #Python #DataScience #ScientificComputing #ComplexAnalysis

---

### Instagram (500 chars)

The beauty of complex analysis in one image.

The Residue Theorem says: to compute an integral around a closed curve, just find the "residues" at the poles inside and sum them up.

∮f(z)dz = 2πi × ∑(residues)

Top left: magnitude of f(z) = 1/(z²+1)
Top right: phase showing singularities at z = ±i
Bottom left: real integral area (= π/2)
Bottom right: how different contours capture different poles

This is how we turn "impossible" integrals into elegant calculations.

Built with Python, NumPy, and matplotlib.

#ComplexAnalysis
#Mathematics
#Python
#DataVisualization
#Science
#MathIsBeautiful
