# Social Media Posts: RSA Encryption Basics

## SHORT-FORM POSTS

### Twitter/X (< 280 chars)
Ever wonder how your data stays private online? RSA encryption uses two primes p and q to create a public key anyone can use, but only YOU can decrypt with your private key. Math magic: c = m^e mod n

#Python #Cryptography #Math #InfoSec

---

### Bluesky (< 300 chars)
RSA encryption explained: Pick two primes p and q, multiply to get n = p × q. The "trapdoor" is that factoring n back into p and q is computationally hard. Your public key encrypts (c = m^e mod n), only your private key decrypts (m = c^d mod n).

#Cryptography #Mathematics #Security

---

### Threads (< 500 chars)
Just built RSA encryption from scratch in Python!

The magic: Anyone can encrypt a message to you using your public key, but ONLY you can decrypt it with your private key.

The math is beautiful:
- Pick primes p and q
- n = p × q (public)
- φ(n) = (p-1)(q-1)
- Find e and d where e × d ≡ 1 (mod φ(n))

Encrypt: c = m^e mod n
Decrypt: m = c^d mod n

Euler's theorem guarantees it works every time!

---

### Mastodon (< 500 chars)
Implemented RSA from first principles using Miller-Rabin primality testing and the Extended Euclidean Algorithm.

Key insight: Security relies on the factoring problem. Computing n = p × q is O(n²), but factoring n → (p,q) requires sub-exponential time via GNFS.

Performance scales poorly: decryption is slower than encryption because d >> e (we use e = 65537, a Fermat prime).

2048-bit keys provide ~112 bits of security. Quantum computers will break this via Shor's algorithm.

#Cryptography #Python #Mathematics #InfoSec


## LONG-FORM POSTS

### Reddit

**Title:** I built RSA encryption from scratch in Python - here's what I learned about the math behind your internet security

**Body:**

I've always been curious about how public-key cryptography actually works, so I decided to implement RSA from the ground up. Here's a breakdown:

**The Core Idea (ELI5)**

Imagine a mailbox where anyone can drop in letters (encrypt), but only you have the key to open it (decrypt). That's public-key cryptography.

**The Math**

1. Pick two prime numbers p and q
2. Multiply them: n = p × q (this is public)
3. Calculate φ(n) = (p-1)(q-1) (Euler's totient)
4. Find e where gcd(e, φ(n)) = 1 (public exponent, usually 65537)
5. Find d where e × d ≡ 1 (mod φ(n)) (private exponent)

**Encryption/Decryption**

- Encrypt: c = m^e mod n
- Decrypt: m = c^d mod n

**Why It's Secure**

Multiplying p × q is easy. Factoring n back into p and q is HARD (sub-exponential time). That's the "trapdoor" function.

**What I Learned**

- Decryption is slower than encryption because d is much larger than e
- Key generation time grows rapidly with key size due to primality testing
- 2048-bit keys are the current minimum recommendation (~112 bits of security)
- RSA will be vulnerable to quantum computers running Shor's algorithm

**Try It Yourself**

View and run the interactive notebook here: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rsa_encryption_basics.ipynb

Happy to answer questions about the implementation!

---

### Facebook (< 500 chars)
Ever wonder how your online banking stays secure? It's thanks to RSA encryption, invented in 1977 and still protecting your data today!

The clever trick: Anyone can encrypt a message to you using public math, but only YOU can decrypt it with your secret key. The security comes from a simple fact - multiplying two huge prime numbers is easy, but factoring the result is incredibly hard!

I implemented it from scratch in Python. Check out the interactive notebook: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rsa_encryption_basics.ipynb

---

### LinkedIn (< 1000 chars)
Exploring Cryptographic Foundations: RSA Implementation from First Principles

I recently completed a deep dive into RSA encryption, implementing the algorithm from scratch to understand the mathematical foundations that secure modern digital communication.

Key Technical Components:
- Miller-Rabin primality testing for prime generation
- Extended Euclidean Algorithm for modular inverse computation
- Performance analysis across key sizes (64-bit to 1024-bit)

Key Findings:

1. Asymmetric Performance: Decryption is consistently slower than encryption due to the private exponent d being significantly larger than the public exponent e (65537)

2. Security Scaling: Current NIST recommendations specify 2048-bit minimum (~112 bits of security), with 3072-bit for long-term protection

3. Quantum Vulnerability: Shor's algorithm poses an existential threat to RSA, driving migration to post-quantum cryptographic schemes

This exercise reinforced the elegance of number theory in practical security applications - Euler's theorem provides the mathematical guarantee that decryption recovers the original message.

View the full implementation with visualizations: https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rsa_encryption_basics.ipynb

#Cryptography #Python #InformationSecurity #Mathematics #SoftwareEngineering

---

### Instagram (< 500 chars)
RSA encryption: the math protecting your digital life since 1977

The concept is beautifully simple:
- Two huge prime numbers create your keys
- Anyone can lock a message with your public key
- Only YOU can unlock it with your private key

The security? Multiplying primes is easy.
Factoring them apart is nearly impossible.

c = m^e mod n (encrypt)
m = c^d mod n (decrypt)

Swipe to see performance analysis across different key sizes and the "scrambling" effect of modular exponentiation

#Cryptography #Python #Math #Coding #DataScience #Security #Programming #STEM #LearnToCode #Encryption
