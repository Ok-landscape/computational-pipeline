# Social Media Posts: Rayleigh Quotient Iteration

================================================================================
## SHORT-FORM POSTS
================================================================================

### Twitter/X (280 chars)
--------------------------------------------------------------------------------
Rayleigh Quotient Iteration achieves CUBIC convergence for eigenvalues - the number of correct digits TRIPLES each iteration! Just 3-5 iterations to machine precision.

#Python #LinearAlgebra #Math #Science #NumericalMethods

--------------------------------------------------------------------------------

### Bluesky (300 chars)
--------------------------------------------------------------------------------
Exploring Rayleigh Quotient Iteration: a powerful eigenvalue algorithm with cubic convergence. The Rayleigh quotient ρ(v) = vᵀAv/vᵀv provides optimal shifts, making each iteration triple the number of correct digits. Implemented in Python with NumPy/SciPy.

#Science #Math #Python

--------------------------------------------------------------------------------

### Threads (500 chars)
--------------------------------------------------------------------------------
Just implemented Rayleigh Quotient Iteration - one of the fastest eigenvalue algorithms out there!

The magic: it uses the Rayleigh quotient ρ(v) = vᵀAv/vᵀv as a dynamically updating shift. This means cubic convergence - your accuracy TRIPLES each iteration.

Compare that to regular power iteration (linear convergence) and you see why RQI is special. It reaches machine precision in just 3-5 iterations.

Perfect for when you need one eigenvalue with extreme precision.

#Math #Python #Science

--------------------------------------------------------------------------------

### Mastodon (500 chars)
--------------------------------------------------------------------------------
Implemented Rayleigh Quotient Iteration for eigenvalue computation.

Key insight: The Rayleigh quotient ρ(v) = vᵀAv/vᵀv approximates eigenvalues with O(ε²) error when v has O(ε) error from the true eigenvector. Using this as a shift in inverse iteration gives:

ε_{k+1} = O(ε_k³) — cubic convergence!

Comparison:
- Power iteration: linear
- Inverse iteration: linear
- RQI: cubic

Trade-off: Can't reuse matrix factorizations between iterations.

#LinearAlgebra #NumericalMethods #Python #Math

--------------------------------------------------------------------------------

================================================================================
## LONG-FORM POSTS
================================================================================

### Reddit (r/learnpython or r/math)
--------------------------------------------------------------------------------
**Title:** Rayleigh Quotient Iteration: How to Triple Your Eigenvalue Precision Each Iteration

**Body:**

I created a Jupyter notebook exploring Rayleigh Quotient Iteration (RQI), and wanted to share what I learned about this elegant algorithm.

**What is it?**

RQI finds eigenvalues and eigenvectors of matrices with cubic convergence - meaning the number of correct digits approximately triples each iteration. That's incredibly fast!

**How does it work?**

The algorithm combines two ideas:

1. **Rayleigh quotient**: For a vector v and matrix A, compute ρ(v) = vᵀAv/vᵀv. This gives the "best" eigenvalue estimate for that vector.

2. **Inverse iteration**: Solve (A - σI)w = v and normalize. This amplifies the eigenvector component nearest to shift σ.

The trick: RQI uses the Rayleigh quotient as the shift, updating it each iteration. Since ρ(v) approximates the eigenvalue with O(ε²) error when v has O(ε) error, you get:

- Shift error: O(ε²)
- New vector error: O(ε²)
- Combined: O(ε³) — cubic convergence!

**Key results from my implementation:**

- RQI converges in 3-5 iterations to machine precision
- Regular inverse iteration (fixed shift) needs 20+ iterations
- The log-log plot of errors shows slope ≈ 3, confirming cubic rate

**When to use RQI:**

- Need a single eigenvalue/eigenvector with high precision
- Have a good initial guess
- As refinement after other methods (like QR algorithm)

**Caveats:**

- Must solve a different linear system each iteration (can't reuse LU factorization)
- Converges to the nearest eigenvalue - may not be the one you want
- Matrix becomes ill-conditioned near convergence

View the full notebook with interactive code here:
https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rayleigh_quotient_iteration.ipynb

Happy to answer questions about the implementation!

--------------------------------------------------------------------------------

### Facebook (500 chars)
--------------------------------------------------------------------------------
Ever wonder how computers find eigenvalues so precisely?

Rayleigh Quotient Iteration is one of the fastest methods - it triples your accuracy with each step! Starting from a random guess, it reaches machine precision in just 3-5 iterations.

The clever part: it automatically adjusts its approach at each step using something called the Rayleigh quotient, always homing in on the nearest eigenvalue.

I made a notebook showing how it works with Python:
https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rayleigh_quotient_iteration.ipynb

--------------------------------------------------------------------------------

### LinkedIn (1000 chars)
--------------------------------------------------------------------------------
**Implementing Rayleigh Quotient Iteration: A Study in Algorithm Design**

I recently implemented Rayleigh Quotient Iteration (RQI) for eigenvalue computation, demonstrating several important numerical analysis concepts.

**Technical Highlights:**

RQI achieves cubic convergence by combining inverse iteration with dynamically updated Rayleigh quotient shifts. The mathematical insight: if a vector approximates an eigenvector with error O(ε), the Rayleigh quotient approximates the eigenvalue with error O(ε²). This quadratic error improvement, combined with inverse iteration, yields cubic overall convergence.

**Implementation Details:**
- Python with NumPy/SciPy
- Comparison against standard inverse iteration
- Convergence rate visualization confirming theoretical predictions
- Robust handling of near-singular systems

**Results:**
- 3-5 iterations to machine precision (vs. 20+ for inverse iteration)
- Empirical convergence rate ≈ 3 (cubic), matching theory

**Skills Demonstrated:**
- Numerical linear algebra
- Algorithm analysis and comparison
- Scientific visualization
- Mathematical software development

View the complete implementation and analysis:
https://cocalc.com/github/Ok-landscape/computational-pipeline/blob/main/notebooks/published/rayleigh_quotient_iteration.ipynb

#NumericalAnalysis #Python #LinearAlgebra #ScientificComputing #DataScience

--------------------------------------------------------------------------------

### Instagram (500 chars)
--------------------------------------------------------------------------------
Cubic convergence in action!

This plot shows Rayleigh Quotient Iteration crushing regular inverse iteration for finding eigenvalues.

The secret? It automatically adjusts its strategy each step using the Rayleigh quotient:
ρ(v) = vᵀAv/vᵀv

Result: accuracy TRIPLES every iteration.

Blue line = RQI (3-5 iterations)
Red line = Inverse iteration (20+ iterations)

Sometimes the elegant solution is also the fastest one.

#math #python #coding #datascience #linearalgebra #numericalanalysis #science #visualization #matplotlib

--------------------------------------------------------------------------------
