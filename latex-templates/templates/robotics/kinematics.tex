\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{float}
\usepackage[makestderr]{pythontex}

\title{Robot Kinematics: Forward and Inverse Analysis}
\author{Computational Robotics Templates}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This document presents a comprehensive analysis of robot kinematics using the Denavit-Hartenberg (DH) convention. We explore forward kinematics for a 3-DOF planar manipulator and 6-DOF articulated arm, implement inverse kinematics solutions using both geometric and numerical methods, compute the Jacobian matrix for velocity analysis, and visualize the robot workspace. The analysis demonstrates the mathematical foundations essential for robot motion planning and control.
\end{abstract}

\section{Introduction}
Robot kinematics is the study of motion without considering the forces that cause it. Forward kinematics determines the end-effector position and orientation given joint angles, while inverse kinematics solves for joint angles given a desired end-effector pose. These fundamental concepts are critical for robot programming, trajectory planning, and real-time control.

\section{Mathematical Framework}

\subsection{Denavit-Hartenberg Convention}
The DH convention provides a systematic method for assigning coordinate frames to each link. The transformation from frame $i-1$ to frame $i$ is:
\begin{equation}
{}^{i-1}T_i = \begin{bmatrix}
\cos\theta_i & -\sin\theta_i\cos\alpha_i & \sin\theta_i\sin\alpha_i & a_i\cos\theta_i \\
\sin\theta_i & \cos\theta_i\cos\alpha_i & -\cos\theta_i\sin\alpha_i & a_i\sin\theta_i \\
0 & \sin\alpha_i & \cos\alpha_i & d_i \\
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}

where $\theta_i$ is the joint angle, $d_i$ is the link offset, $a_i$ is the link length, and $\alpha_i$ is the link twist.

\subsection{Forward Kinematics}
For an $n$-DOF manipulator, the end-effector pose is:
\begin{equation}
{}^0T_n = {}^0T_1 \cdot {}^1T_2 \cdot \ldots \cdot {}^{n-1}T_n = \prod_{i=1}^{n} {}^{i-1}T_i
\end{equation}

\subsection{Jacobian Matrix}
The Jacobian relates joint velocities to end-effector velocities:
\begin{equation}
\begin{bmatrix} \mathbf{v} \\ \boldsymbol{\omega} \end{bmatrix} = \mathbf{J}(\mathbf{q}) \dot{\mathbf{q}}
\end{equation}

For a revolute joint $i$:
\begin{equation}
\mathbf{J}_i = \begin{bmatrix} \mathbf{z}_{i-1} \times (\mathbf{o}_n - \mathbf{o}_{i-1}) \\ \mathbf{z}_{i-1} \end{bmatrix}
\end{equation}

\subsection{Inverse Kinematics}
The inverse kinematics problem solves for $\mathbf{q}$ given ${}^0T_n$. For numerical solutions, the Newton-Raphson method is:
\begin{equation}
\mathbf{q}_{k+1} = \mathbf{q}_k + \mathbf{J}^{-1}(\mathbf{q}_k) \cdot \Delta\mathbf{x}
\end{equation}

where $\Delta\mathbf{x}$ is the pose error.

\section{Computational Analysis}

\begin{pycode}
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import fsolve
plt.rc('text', usetex=True)
plt.rc('font', family='serif')

np.random.seed(42)

# DH transformation matrix
def dh_transform(theta, d, a, alpha):
    """Compute DH transformation matrix"""
    ct, st = np.cos(theta), np.sin(theta)
    ca, sa = np.cos(alpha), np.sin(alpha)
    return np.array([
        [ct, -st*ca, st*sa, a*ct],
        [st, ct*ca, -ct*sa, a*st],
        [0, sa, ca, d],
        [0, 0, 0, 1]
    ])

# 3-DOF Planar Manipulator parameters
L1, L2, L3 = 1.0, 0.8, 0.5  # Link lengths

def forward_kinematics_3dof(q):
    """Forward kinematics for 3-DOF planar arm"""
    T01 = dh_transform(q[0], 0, L1, 0)
    T12 = dh_transform(q[1], 0, L2, 0)
    T23 = dh_transform(q[2], 0, L3, 0)
    T03 = T01 @ T12 @ T23
    return T03

def get_joint_positions_3dof(q):
    """Get all joint positions for visualization"""
    T01 = dh_transform(q[0], 0, L1, 0)
    T12 = dh_transform(q[1], 0, L2, 0)
    T23 = dh_transform(q[2], 0, L3, 0)

    p0 = np.array([0, 0, 0])
    p1 = T01[:3, 3]
    p2 = (T01 @ T12)[:3, 3]
    p3 = (T01 @ T12 @ T23)[:3, 3]

    return np.array([p0, p1, p2, p3])

# Jacobian for 3-DOF planar arm
def jacobian_3dof(q):
    """Compute Jacobian matrix for 3-DOF planar arm"""
    c1 = np.cos(q[0])
    s1 = np.sin(q[0])
    c12 = np.cos(q[0] + q[1])
    s12 = np.sin(q[0] + q[1])
    c123 = np.cos(q[0] + q[1] + q[2])
    s123 = np.sin(q[0] + q[1] + q[2])

    J = np.array([
        [-L1*s1 - L2*s12 - L3*s123, -L2*s12 - L3*s123, -L3*s123],
        [L1*c1 + L2*c12 + L3*c123, L2*c12 + L3*c123, L3*c123],
        [1, 1, 1]
    ])
    return J

# Inverse kinematics using numerical method
def inverse_kinematics_3dof(target_pos, target_orient, q_init):
    """Inverse kinematics using Newton-Raphson"""
    def error_func(q):
        T = forward_kinematics_3dof(q)
        pos_error = target_pos - T[:2, 3]
        orient_error = target_orient - (q[0] + q[1] + q[2])
        return np.array([pos_error[0], pos_error[1], orient_error])

    q_solution, info, ier, msg = fsolve(error_func, q_init, full_output=True)
    return q_solution, ier == 1

# Store results for reporting
results = {}
\end{pycode}

\subsection{3-DOF Planar Manipulator Analysis}

\begin{pycode}
# Test configuration
q_test = np.array([np.pi/4, np.pi/6, -np.pi/8])
T_end = forward_kinematics_3dof(q_test)
positions = get_joint_positions_3dof(q_test)

results['end_effector_x'] = T_end[0, 3]
results['end_effector_y'] = T_end[1, 3]
results['orientation'] = np.rad2deg(q_test[0] + q_test[1] + q_test[2])

# Plot 3-DOF arm configuration
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Configuration visualization
ax1 = axes[0, 0]
ax1.plot(positions[:, 0], positions[:, 1], 'b-o', linewidth=3, markersize=10, label='Links')
ax1.scatter(positions[-1, 0], positions[-1, 1], s=200, c='red', marker='*',
            zorder=5, label='End-effector')
ax1.set_xlabel('X (m)')
ax1.set_ylabel('Y (m)')
ax1.set_title('3-DOF Planar Manipulator Configuration')
ax1.grid(True, alpha=0.3)
ax1.axis('equal')
ax1.legend()
ax1.set_xlim(-0.5, 2.5)
ax1.set_ylim(-0.5, 2.5)

# Draw joint circles
for i, pos in enumerate(positions):
    circle = plt.Circle((pos[0], pos[1]), 0.05, color='blue', fill=True)
    ax1.add_patch(circle)

# Workspace visualization
ax2 = axes[0, 1]
n_samples = 5000
workspace_points = []
for _ in range(n_samples):
    q_rand = np.random.uniform([-np.pi, -np.pi, -np.pi], [np.pi, np.pi, np.pi])
    T = forward_kinematics_3dof(q_rand)
    workspace_points.append([T[0, 3], T[1, 3]])

workspace_points = np.array(workspace_points)
ax2.scatter(workspace_points[:, 0], workspace_points[:, 1], s=1, alpha=0.3, c='blue')
ax2.set_xlabel('X (m)')
ax2.set_ylabel('Y (m)')
ax2.set_title('Robot Workspace (Reachable Points)')
ax2.grid(True, alpha=0.3)
ax2.axis('equal')

# Calculate workspace boundaries
r_min = abs(L1 - L2 - L3)
r_max = L1 + L2 + L3
results['workspace_outer'] = r_max
results['workspace_inner'] = r_min

# Jacobian analysis
ax3 = axes[1, 0]
q_range = np.linspace(-np.pi, np.pi, 100)
manipulability = []
for q1 in q_range:
    q = np.array([q1, np.pi/4, 0])
    J = jacobian_3dof(q)
    J_pos = J[:2, :]  # Position Jacobian
    w = np.sqrt(np.linalg.det(J_pos @ J_pos.T))
    manipulability.append(w)

ax3.plot(np.rad2deg(q_range), manipulability, 'b-', linewidth=2)
ax3.set_xlabel(r'Joint 1 Angle ($^\circ$)')
ax3.set_ylabel('Manipulability Index')
ax3.set_title('Manipulability vs Joint 1 Angle')
ax3.grid(True, alpha=0.3)
ax3.axhline(y=0, color='r', linestyle='--', alpha=0.5, label='Singularity')
ax3.legend()

results['max_manipulability'] = max(manipulability)

# Inverse kinematics demonstration
ax4 = axes[1, 1]
target_pos = np.array([1.5, 1.0])
target_orient = np.pi/6
q_init = np.array([0.5, 0.5, 0.5])
q_ik, success = inverse_kinematics_3dof(target_pos, target_orient, q_init)

if success:
    positions_ik = get_joint_positions_3dof(q_ik)
    ax4.plot(positions_ik[:, 0], positions_ik[:, 1], 'g-o', linewidth=3, markersize=10)
    ax4.scatter(target_pos[0], target_pos[1], s=200, c='red', marker='x',
                linewidths=3, label='Target')
    ax4.scatter(positions_ik[-1, 0], positions_ik[-1, 1], s=100, c='green',
                marker='*', label='Achieved')
    results['ik_error'] = np.linalg.norm(target_pos - positions_ik[-1, :2])
    results['ik_q1'] = np.rad2deg(q_ik[0])
    results['ik_q2'] = np.rad2deg(q_ik[1])
    results['ik_q3'] = np.rad2deg(q_ik[2])
else:
    results['ik_error'] = float('inf')

ax4.set_xlabel('X (m)')
ax4.set_ylabel('Y (m)')
ax4.set_title('Inverse Kinematics Solution')
ax4.grid(True, alpha=0.3)
ax4.axis('equal')
ax4.legend()

plt.tight_layout()
plt.savefig('kinematics_3dof.pdf', bbox_inches='tight', dpi=150)
print(r'\begin{figure}[H]')
print(r'\centering')
print(r'\includegraphics[width=\textwidth]{kinematics_3dof.pdf}')
print(r'\caption{3-DOF planar manipulator analysis: (a) robot configuration, (b) workspace, (c) manipulability index, (d) inverse kinematics solution.}')
print(r'\label{fig:3dof}')
print(r'\end{figure}')
plt.close()
\end{pycode}

\subsection{6-DOF Articulated Manipulator}

\begin{pycode}
# 6-DOF robot parameters (similar to industrial robot)
# DH parameters: [theta, d, a, alpha]
dh_params = [
    [0, 0.4, 0.025, np.pi/2],    # Joint 1
    [0, 0, 0.56, 0],              # Joint 2
    [0, 0, 0.035, np.pi/2],       # Joint 3
    [0, 0.515, 0, -np.pi/2],      # Joint 4
    [0, 0, 0, np.pi/2],           # Joint 5
    [0, 0.08, 0, 0]               # Joint 6
]

def forward_kinematics_6dof(q):
    """Forward kinematics for 6-DOF robot"""
    T = np.eye(4)
    for i in range(6):
        theta = q[i] + dh_params[i][0]
        d = dh_params[i][1]
        a = dh_params[i][2]
        alpha = dh_params[i][3]
        T = T @ dh_transform(theta, d, a, alpha)
    return T

def get_joint_positions_6dof(q):
    """Get all joint positions for 6-DOF robot"""
    positions = [np.array([0, 0, 0])]
    T = np.eye(4)
    for i in range(6):
        theta = q[i] + dh_params[i][0]
        d = dh_params[i][1]
        a = dh_params[i][2]
        alpha = dh_params[i][3]
        T = T @ dh_transform(theta, d, a, alpha)
        positions.append(T[:3, 3].copy())
    return np.array(positions)

# 3D visualization of 6-DOF robot
fig = plt.figure(figsize=(14, 6))

# Configuration 1: Home position
ax1 = fig.add_subplot(121, projection='3d')
q_home = np.array([0, 0, 0, 0, 0, 0])
pos_home = get_joint_positions_6dof(q_home)
ax1.plot(pos_home[:, 0], pos_home[:, 1], pos_home[:, 2], 'b-o', linewidth=3, markersize=8)
ax1.scatter(pos_home[-1, 0], pos_home[-1, 1], pos_home[-1, 2], s=200, c='red', marker='*')
ax1.set_xlabel('X (m)')
ax1.set_ylabel('Y (m)')
ax1.set_zlabel('Z (m)')
ax1.set_title('6-DOF Robot: Home Configuration')

# Configuration 2: Working position
ax2 = fig.add_subplot(122, projection='3d')
q_work = np.array([np.pi/4, -np.pi/6, np.pi/4, np.pi/3, -np.pi/4, np.pi/6])
pos_work = get_joint_positions_6dof(q_work)
ax2.plot(pos_work[:, 0], pos_work[:, 1], pos_work[:, 2], 'g-o', linewidth=3, markersize=8)
ax2.scatter(pos_work[-1, 0], pos_work[-1, 1], pos_work[-1, 2], s=200, c='red', marker='*')
ax2.set_xlabel('X (m)')
ax2.set_ylabel('Y (m)')
ax2.set_zlabel('Z (m)')
ax2.set_title('6-DOF Robot: Working Configuration')

T_home = forward_kinematics_6dof(q_home)
T_work = forward_kinematics_6dof(q_work)
results['6dof_home_pos'] = T_home[:3, 3]
results['6dof_work_pos'] = T_work[:3, 3]

plt.tight_layout()
plt.savefig('kinematics_6dof.pdf', bbox_inches='tight', dpi=150)
print(r'\begin{figure}[H]')
print(r'\centering')
print(r'\includegraphics[width=\textwidth]{kinematics_6dof.pdf}')
print(r'\caption{6-DOF articulated manipulator in home and working configurations.}')
print(r'\label{fig:6dof}')
print(r'\end{figure}')
plt.close()
\end{pycode}

\subsection{Trajectory Generation}

\begin{pycode}
# Joint space trajectory with trapezoidal velocity profile
def trapezoidal_trajectory(q_start, q_end, t_total, n_points=100):
    """Generate trapezoidal velocity profile trajectory"""
    t = np.linspace(0, t_total, n_points)
    q = np.zeros((n_points, len(q_start)))
    qd = np.zeros((n_points, len(q_start)))
    qdd = np.zeros((n_points, len(q_start)))

    t_acc = t_total / 3  # Acceleration time

    for i in range(len(q_start)):
        dq = q_end[i] - q_start[i]
        a_max = 3 * dq / (t_total * t_acc)
        v_max = a_max * t_acc

        for j, tj in enumerate(t):
            if tj < t_acc:
                q[j, i] = q_start[i] + 0.5 * a_max * tj**2
                qd[j, i] = a_max * tj
                qdd[j, i] = a_max
            elif tj < t_total - t_acc:
                q[j, i] = q_start[i] + 0.5 * a_max * t_acc**2 + v_max * (tj - t_acc)
                qd[j, i] = v_max
                qdd[j, i] = 0
            else:
                t_dec = tj - (t_total - t_acc)
                q[j, i] = q_end[i] - 0.5 * a_max * (t_acc - t_dec)**2
                qd[j, i] = a_max * (t_acc - t_dec)
                qdd[j, i] = -a_max

    return t, q, qd, qdd

# Generate trajectory
q_start = np.array([0, np.pi/6, -np.pi/6])
q_end = np.array([np.pi/3, -np.pi/4, np.pi/4])
t_total = 2.0

t, q_traj, qd_traj, qdd_traj = trapezoidal_trajectory(q_start, q_end, t_total)

fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Joint positions
ax1 = axes[0, 0]
for i in range(3):
    ax1.plot(t, np.rad2deg(q_traj[:, i]), linewidth=2, label=f'Joint {i+1}')
ax1.set_xlabel('Time (s)')
ax1.set_ylabel(r'Joint Angle ($^\circ$)')
ax1.set_title('Joint Position Trajectory')
ax1.grid(True, alpha=0.3)
ax1.legend()

# Joint velocities
ax2 = axes[0, 1]
for i in range(3):
    ax2.plot(t, np.rad2deg(qd_traj[:, i]), linewidth=2, label=f'Joint {i+1}')
ax2.set_xlabel('Time (s)')
ax2.set_ylabel(r'Joint Velocity ($^\circ$/s)')
ax2.set_title('Joint Velocity Profile (Trapezoidal)')
ax2.grid(True, alpha=0.3)
ax2.legend()

# End-effector path in Cartesian space
ax3 = axes[1, 0]
ee_path = []
for q in q_traj:
    T = forward_kinematics_3dof(q)
    ee_path.append([T[0, 3], T[1, 3]])
ee_path = np.array(ee_path)
ax3.plot(ee_path[:, 0], ee_path[:, 1], 'b-', linewidth=2)
ax3.scatter(ee_path[0, 0], ee_path[0, 1], s=100, c='green', marker='o', label='Start')
ax3.scatter(ee_path[-1, 0], ee_path[-1, 1], s=100, c='red', marker='*', label='End')
ax3.set_xlabel('X (m)')
ax3.set_ylabel('Y (m)')
ax3.set_title('End-Effector Cartesian Path')
ax3.grid(True, alpha=0.3)
ax3.axis('equal')
ax3.legend()

results['path_length'] = np.sum(np.sqrt(np.sum(np.diff(ee_path, axis=0)**2, axis=1)))

# End-effector velocity
ax4 = axes[1, 1]
ee_vel = []
for i, q in enumerate(q_traj):
    J = jacobian_3dof(q)
    v = J[:2, :] @ qd_traj[i, :]
    ee_vel.append(np.linalg.norm(v))
ax4.plot(t, ee_vel, 'r-', linewidth=2)
ax4.set_xlabel('Time (s)')
ax4.set_ylabel('Velocity (m/s)')
ax4.set_title('End-Effector Speed')
ax4.grid(True, alpha=0.3)

results['max_ee_velocity'] = max(ee_vel)

plt.tight_layout()
plt.savefig('kinematics_trajectory.pdf', bbox_inches='tight', dpi=150)
print(r'\begin{figure}[H]')
print(r'\centering')
print(r'\includegraphics[width=\textwidth]{kinematics_trajectory.pdf}')
print(r'\caption{Trajectory generation: joint space profiles and Cartesian end-effector path.}')
print(r'\label{fig:trajectory}')
print(r'\end{figure}')
plt.close()
\end{pycode}

\subsection{Singularity Analysis}

\begin{pycode}
# Analyze singularities through determinant of Jacobian
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Singularity map
ax1 = axes[0]
q1_range = np.linspace(-np.pi, np.pi, 50)
q2_range = np.linspace(-np.pi, np.pi, 50)
Q1, Q2 = np.meshgrid(q1_range, q2_range)
det_J = np.zeros_like(Q1)

for i in range(len(q1_range)):
    for j in range(len(q2_range)):
        q = np.array([q1_range[i], q2_range[j], 0])
        J = jacobian_3dof(q)
        J_pos = J[:2, :]
        det_J[j, i] = np.abs(np.linalg.det(J_pos @ J_pos.T))

contour = ax1.contourf(np.rad2deg(Q1), np.rad2deg(Q2), det_J, levels=20, cmap='viridis')
plt.colorbar(contour, ax=ax1, label='Manipulability')
ax1.set_xlabel(r'Joint 1 ($^\circ$)')
ax1.set_ylabel(r'Joint 2 ($^\circ$)')
ax1.set_title('Singularity Map (Joint 3 = 0)')

# Condition number analysis
ax2 = axes[1]
q1_vals = np.linspace(-np.pi, np.pi, 200)
cond_nums = []
for q1 in q1_vals:
    q = np.array([q1, np.pi/4, -np.pi/8])
    J = jacobian_3dof(q)
    J_pos = J[:2, :]
    s = np.linalg.svd(J_pos, compute_uv=False)
    if s[-1] > 1e-10:
        cond_nums.append(s[0] / s[-1])
    else:
        cond_nums.append(1000)

ax2.semilogy(np.rad2deg(q1_vals), cond_nums, 'b-', linewidth=2)
ax2.set_xlabel(r'Joint 1 Angle ($^\circ$)')
ax2.set_ylabel('Condition Number')
ax2.set_title('Jacobian Condition Number')
ax2.grid(True, alpha=0.3)
ax2.axhline(y=10, color='r', linestyle='--', label='Good conditioning threshold')
ax2.legend()

results['min_condition'] = min(cond_nums)

plt.tight_layout()
plt.savefig('kinematics_singularity.pdf', bbox_inches='tight', dpi=150)
print(r'\begin{figure}[H]')
print(r'\centering')
print(r'\includegraphics[width=\textwidth]{kinematics_singularity.pdf}')
print(r'\caption{Singularity analysis: manipulability map and Jacobian condition number.}')
print(r'\label{fig:singularity}')
print(r'\end{figure}')
plt.close()
\end{pycode}

\subsection{Animation Frames: Robot Motion}

\begin{pycode}
# Generate multiple frames showing robot motion
fig, axes = plt.subplots(2, 3, figsize=(14, 9))

t_frames = [0, 0.4, 0.8, 1.2, 1.6, 2.0]
for idx, t_frame in enumerate(t_frames):
    ax = axes[idx // 3, idx % 3]
    frame_idx = int(t_frame / t_total * (len(t) - 1))
    q = q_traj[frame_idx]
    positions = get_joint_positions_3dof(q)

    ax.plot(positions[:, 0], positions[:, 1], 'b-o', linewidth=3, markersize=8)
    ax.scatter(positions[-1, 0], positions[-1, 1], s=150, c='red', marker='*')

    # Draw full path
    ax.plot(ee_path[:, 0], ee_path[:, 1], 'g--', alpha=0.3, linewidth=1)
    ax.plot(ee_path[:frame_idx+1, 0], ee_path[:frame_idx+1, 1], 'g-', linewidth=2)

    ax.set_xlabel('X (m)')
    ax.set_ylabel('Y (m)')
    ax.set_title(f't = {t_frame:.1f} s')
    ax.grid(True, alpha=0.3)
    ax.set_xlim(-0.5, 2.5)
    ax.set_ylim(-1.0, 2.0)
    ax.set_aspect('equal')

plt.tight_layout()
plt.savefig('kinematics_motion.pdf', bbox_inches='tight', dpi=150)
print(r'\begin{figure}[H]')
print(r'\centering')
print(r'\includegraphics[width=\textwidth]{kinematics_motion.pdf}')
print(r'\caption{Robot motion sequence showing arm configuration at different time instants.}')
print(r'\label{fig:motion}')
print(r'\end{figure}')
plt.close()
\end{pycode}

\section{Results and Discussion}

\subsection{Forward Kinematics Results}
For the test configuration with joint angles $q = [\py{np.rad2deg(q_test[0]):.1f}^\circ, \py{np.rad2deg(q_test[1]):.1f}^\circ, \py{np.rad2deg(q_test[2]):.1f}^\circ]$:

\begin{table}[H]
\centering
\caption{Forward Kinematics Results}
\label{tab:fk_results}
\begin{tabular}{lcc}
\toprule
\textbf{Parameter} & \textbf{Value} & \textbf{Unit} \\
\midrule
End-effector X & \py{f"{results['end_effector_x']:.4f}"} & m \\
End-effector Y & \py{f"{results['end_effector_y']:.4f}"} & m \\
End-effector orientation & \py{f"{results['orientation']:.2f}"} & degrees \\
\midrule
Workspace outer radius & \py{f"{results['workspace_outer']:.2f}"} & m \\
Workspace inner radius & \py{f"{results['workspace_inner']:.2f}"} & m \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Inverse Kinematics Results}
The inverse kinematics solver successfully found a solution for target position $(\py{target_pos[0]:.1f}, \py{target_pos[1]:.1f})$ m:

\begin{table}[H]
\centering
\caption{Inverse Kinematics Solution}
\label{tab:ik_results}
\begin{tabular}{lcc}
\toprule
\textbf{Joint} & \textbf{Angle} & \textbf{Unit} \\
\midrule
Joint 1 & \py{f"{results['ik_q1']:.2f}"} & degrees \\
Joint 2 & \py{f"{results['ik_q2']:.2f}"} & degrees \\
Joint 3 & \py{f"{results['ik_q3']:.2f}"} & degrees \\
\midrule
Position error & \py{f"{results['ik_error']*1000:.4f}"} & mm \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Trajectory Analysis}
The trapezoidal velocity profile trajectory yielded:
\begin{itemize}
    \item Path length: \py{f"{results['path_length']:.4f}"} m
    \item Maximum end-effector velocity: \py{f"{results['max_ee_velocity']:.4f}"} m/s
    \item Maximum manipulability index: \py{f"{results['max_manipulability']:.4f}"}
    \item Minimum condition number: \py{f"{results['min_condition']:.2f}"}
\end{itemize}

\subsection{6-DOF Robot Results}
The 6-DOF articulated manipulator end-effector positions:
\begin{itemize}
    \item Home configuration: $(\py{f"{results['6dof_home_pos'][0]:.3f}"}, \py{f"{results['6dof_home_pos'][1]:.3f}"}, \py{f"{results['6dof_home_pos'][2]:.3f}"})$ m
    \item Working configuration: $(\py{f"{results['6dof_work_pos'][0]:.3f}"}, \py{f"{results['6dof_work_pos'][1]:.3f}"}, \py{f"{results['6dof_work_pos'][2]:.3f}"})$ m
\end{itemize}

\section{Conclusion}
This analysis demonstrated the fundamental concepts of robot kinematics including forward and inverse kinematics using the DH convention, Jacobian computation for velocity analysis, workspace visualization, trajectory generation with trapezoidal velocity profiles, and singularity analysis. The numerical methods presented are applicable to manipulators of varying complexity and form the foundation for advanced robot motion planning and control algorithms.

\end{document}
