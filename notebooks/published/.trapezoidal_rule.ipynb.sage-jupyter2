{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-5ceb7434-9311-4cfa-a7a1-34a4e1979675.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1763844043260,"last_ipynb_save":1763844060396,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1763844044117,"exec_count":3,"id":"3d9044","input":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import integrate\n\n# Set plotting style\nplt.rcParams['figure.figsize'] = [12, 8]\nplt.rcParams['font.size'] = 11\nplt.rcParams['axes.grid'] = True\nplt.rcParams['grid.alpha'] = 0.3","kernel":"python3","pos":1,"start":1763844043275,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844044144,"exec_count":4,"id":"5ccbdc","input":"def trapezoidal_rule(f, a, b, n):\n    \"\"\"\n    Compute the definite integral of f from a to b using the composite trapezoidal rule.\n    \n    Parameters:\n    -----------\n    f : callable\n        The function to integrate\n    a : float\n        Lower limit of integration\n    b : float\n        Upper limit of integration\n    n : int\n        Number of subintervals\n    \n    Returns:\n    --------\n    float\n        Approximation of the integral\n    \"\"\"\n    h = (b - a) / n\n    x = np.linspace(a, b, n + 1)\n    y = f(x)\n    \n    # Apply the trapezoidal formula\n    integral = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n    \n    return integral","kernel":"python3","pos":3,"start":1763844044132,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844044163,"exec_count":5,"id":"1debe6","input":"# Define the function\nf1 = lambda x: x**3\n\n# Integration bounds\na, b = 0, 2\nexact_value = 4.0\n\n# Test with different numbers of subintervals\nn_values = [2, 4, 8, 16, 32, 64, 128, 256]\nresults = []\n\nprint(\"Trapezoidal Rule: f(x) = x³ on [0, 2]\")\nprint(\"Exact value: 4.0\")\nprint(\"-\" * 50)\nprint(f\"{'n':>6} {'Approximation':>16} {'Error':>14} {'Ratio':>8}\")\nprint(\"-\" * 50)\n\nprev_error = None\nfor n in n_values:\n    approx = trapezoidal_rule(f1, a, b, n)\n    error = abs(exact_value - approx)\n    \n    if prev_error is not None and error > 0:\n        ratio = prev_error / error\n        print(f\"{n:>6} {approx:>16.10f} {error:>14.2e} {ratio:>8.2f}\")\n    else:\n        print(f\"{n:>6} {approx:>16.10f} {error:>14.2e} {'--':>8}\")\n    \n    results.append((n, approx, error))\n    prev_error = error\n\nprint(\"-\" * 50)\nprint(\"Note: Error ratio ≈ 4 confirms O(h²) convergence\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Trapezoidal Rule: f(x) = x³ on [0, 2]\nExact value: 4.0\n--------------------------------------------------\n     n    Approximation          Error    Ratio\n--------------------------------------------------\n     2     5.0000000000       1.00e+00       --\n     4     4.2500000000       2.50e-01     4.00\n     8     4.0625000000       6.25e-02     4.00\n    16     4.0156250000       1.56e-02     4.00\n    32     4.0039062500       3.91e-03     4.00\n    64     4.0009765625       9.77e-04     4.00\n   128     4.0002441406       2.44e-04     4.00\n   256     4.0000610352       6.10e-05     4.00\n--------------------------------------------------\nNote: Error ratio ≈ 4 confirms O(h²) convergence\n"}},"pos":5,"start":1763844044152,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844044182,"exec_count":6,"id":"9711c3","input":"from scipy.special import erf\n\n# Define the Gaussian function\nf2 = lambda x: np.exp(-x**2)\n\n# Integration bounds\na, b = 0, 1\nexact_value_gaussian = np.sqrt(np.pi) / 2 * erf(1)\n\nprint(f\"Trapezoidal Rule: f(x) = exp(-x²) on [0, 1]\")\nprint(f\"Exact value: {exact_value_gaussian:.10f}\")\nprint(\"-\" * 50)\n\nn_test = [10, 50, 100, 500, 1000]\nfor n in n_test:\n    approx = trapezoidal_rule(f2, a, b, n)\n    error = abs(exact_value_gaussian - approx)\n    print(f\"n = {n:>4}: {approx:.10f}, Error = {error:.2e}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Trapezoidal Rule: f(x) = exp(-x²) on [0, 1]\nExact value: 0.7468241328\n--------------------------------------------------\nn =   10: 0.7462107961, Error = 6.13e-04\nn =   50: 0.7467996072, Error = 2.45e-05\nn =  100: 0.7468180015, Error = 6.13e-06\nn =  500: 0.7468238876, Error = 2.45e-07\nn = 1000: 0.7468240715, Error = 6.13e-08\n"}},"pos":7,"start":1763844044176,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844045168,"exec_count":7,"id":"f06b3e","input":"def visualize_trapezoidal(f, a, b, n, title=\"Trapezoidal Rule Approximation\"):\n    \"\"\"\n    Visualize the trapezoidal rule approximation.\n    \"\"\"\n    # Create fine grid for smooth curve\n    x_fine = np.linspace(a, b, 1000)\n    y_fine = f(x_fine)\n    \n    # Create grid for trapezoids\n    x_trap = np.linspace(a, b, n + 1)\n    y_trap = f(x_trap)\n    \n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot the function\n    ax.plot(x_fine, y_fine, 'b-', linewidth=2, label='$f(x)$')\n    \n    # Fill trapezoids\n    for i in range(n):\n        xs = [x_trap[i], x_trap[i], x_trap[i+1], x_trap[i+1]]\n        ys = [0, y_trap[i], y_trap[i+1], 0]\n        ax.fill(xs, ys, alpha=0.3, color='orange', edgecolor='red', linewidth=1)\n    \n    # Mark the grid points\n    ax.plot(x_trap, y_trap, 'ro', markersize=6)\n    \n    # Calculate the approximation\n    approx = trapezoidal_rule(f, a, b, n)\n    \n    ax.set_xlabel('x', fontsize=12)\n    ax.set_ylabel('f(x)', fontsize=12)\n    ax.set_title(f'{title}\\nn = {n}, Approximation = {approx:.6f}', fontsize=14)\n    ax.legend(loc='best', fontsize=11)\n    ax.set_xlim(a - 0.1, b + 0.1)\n    \n    return fig, ax\n\n# Visualize with sin(x) on [0, π]\nf_sin = lambda x: np.sin(x)\nfig, ax = visualize_trapezoidal(f_sin, 0, np.pi, 8, \n                                 title=r\"Trapezoidal Rule: $\\int_0^\\pi \\sin(x)\\,dx$\")\nexact_sin = 2.0  # Exact value\nax.axhline(y=0, color='k', linewidth=0.5)\nplt.tight_layout()\nplt.show()\n\nprint(f\"\\nExact value: {exact_sin}\")\nprint(f\"Approximation with n=8: {trapezoidal_rule(f_sin, 0, np.pi, 8):.6f}\")","kernel":"python3","output":{"0":{"data":{"image/png":"c30a6bf9fe1bdbafcfc626b1cf906b2f0b83c7d4","text/plain":"<Figure size 1000x600 with 1 Axes>"},"metadata":{"image/png":{"height":583,"width":985}}},"1":{"name":"stdout","text":"\nExact value: 2.0\nApproximation with n=8: 1.974232\n"}},"pos":9,"start":1763844044195,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844046445,"exec_count":8,"id":"18473f","input":"# Test function: f(x) = sin(x) on [0, π], exact integral = 2\nf_test = lambda x: np.sin(x)\na, b = 0, np.pi\nexact = 2.0\n\n# Range of n values\nn_range = np.array([2, 4, 8, 16, 32, 64, 128, 256, 512, 1024])\nh_range = (b - a) / n_range\nerrors = []\n\nfor n in n_range:\n    approx = trapezoidal_rule(f_test, a, b, n)\n    errors.append(abs(exact - approx))\n\nerrors = np.array(errors)\n\n# Plot convergence\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\n# Log-log plot of error vs h\nax1.loglog(h_range, errors, 'bo-', linewidth=2, markersize=8, label='Trapezoidal Error')\n\n# Reference line for O(h²)\nh_ref = np.array([h_range[0], h_range[-1]])\nerror_ref = errors[0] * (h_ref / h_range[0])**2\nax1.loglog(h_ref, error_ref, 'r--', linewidth=2, label='$O(h^2)$ reference')\n\nax1.set_xlabel('Step size $h$', fontsize=12)\nax1.set_ylabel('Absolute Error', fontsize=12)\nax1.set_title('Convergence of Trapezoidal Rule', fontsize=14)\nax1.legend(fontsize=11)\nax1.grid(True, which=\"both\", ls=\"-\", alpha=0.3)\n\n# Log-log plot of error vs n\nax2.loglog(n_range, errors, 'go-', linewidth=2, markersize=8, label='Trapezoidal Error')\n\n# Reference line for O(1/n²)\nn_ref = np.array([n_range[0], n_range[-1]])\nerror_ref_n = errors[0] * (n_range[0] / n_ref)**2\nax2.loglog(n_ref, error_ref_n, 'r--', linewidth=2, label='$O(n^{-2})$ reference')\n\nax2.set_xlabel('Number of subintervals $n$', fontsize=12)\nax2.set_ylabel('Absolute Error', fontsize=12)\nax2.set_title('Error vs Number of Subintervals', fontsize=14)\nax2.legend(fontsize=11)\nax2.grid(True, which=\"both\", ls=\"-\", alpha=0.3)\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"data":{"image/png":"a6a47cba604aeb867ad63e812239c0acea1828d1","text/plain":"<Figure size 1400x500 with 2 Axes>"},"metadata":{"image/png":{"height":481,"width":1384}}}},"pos":11,"start":1763844045187,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844047430,"exec_count":9,"id":"2d1c24","input":"# Define multiple test functions with known integrals\ntest_cases = [\n    (lambda x: x**2, 0, 1, 1/3, r\"$\\int_0^1 x^2\\,dx = 1/3$\"),\n    (lambda x: np.sin(x), 0, np.pi, 2, r\"$\\int_0^\\pi \\sin(x)\\,dx = 2$\"),\n    (lambda x: np.exp(x), 0, 1, np.e - 1, r\"$\\int_0^1 e^x\\,dx = e-1$\"),\n    (lambda x: 1/(1 + x**2), 0, 1, np.pi/4, r\"$\\int_0^1 \\frac{1}{1+x^2}\\,dx = \\pi/4$\"),\n]\n\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\naxes = axes.flatten()\n\nn_values = np.arange(2, 101)\n\nfor idx, (f, a, b, exact, title) in enumerate(test_cases):\n    approximations = [trapezoidal_rule(f, a, b, n) for n in n_values]\n    \n    ax = axes[idx]\n    ax.plot(n_values, approximations, 'b-', linewidth=1.5, label='Trapezoidal')\n    ax.axhline(y=exact, color='r', linestyle='--', linewidth=2, label=f'Exact = {exact:.6f}')\n    \n    ax.set_xlabel('Number of subintervals $n$', fontsize=10)\n    ax.set_ylabel('Integral Value', fontsize=10)\n    ax.set_title(title, fontsize=12)\n    ax.legend(fontsize=9)\n    ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"data":{"image/png":"9c798a0077ec5e8b982ae35d77af1ced0cefc407","text/plain":"<Figure size 1400x1000 with 4 Axes>"},"metadata":{"image/png":{"height":983,"width":1387}}}},"pos":13,"start":1763844046482,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844047565,"exec_count":10,"id":"4efef3","input":"def adaptive_trapezoidal(f, a, b, tol=1e-6, max_iter=20):\n    \"\"\"\n    Adaptive trapezoidal integration with automatic error control.\n    \n    Uses Richardson extrapolation to estimate error.\n    \n    Parameters:\n    -----------\n    f : callable\n        Function to integrate\n    a, b : float\n        Integration bounds\n    tol : float\n        Desired tolerance\n    max_iter : int\n        Maximum number of iterations\n    \n    Returns:\n    --------\n    tuple : (integral, error_estimate, n_final, iterations)\n    \"\"\"\n    n = 1\n    I_old = trapezoidal_rule(f, a, b, n)\n    \n    for iteration in range(1, max_iter + 1):\n        n *= 2\n        I_new = trapezoidal_rule(f, a, b, n)\n        \n        # Error estimate using Richardson extrapolation\n        error_est = abs(I_new - I_old) / 3\n        \n        if error_est < tol:\n            return I_new, error_est, n, iteration\n        \n        I_old = I_new\n    \n    return I_new, error_est, n, max_iter\n\n# Test adaptive integration\nf_test = lambda x: np.exp(-x**2)\na, b = 0, 2\nexact_ref, _ = integrate.quad(f_test, a, b)\n\nprint(\"Adaptive Trapezoidal Rule: f(x) = exp(-x²) on [0, 2]\")\nprint(f\"Reference value (scipy.quad): {exact_ref:.10f}\")\nprint(\"-\" * 60)\n\ntolerances = [1e-3, 1e-6, 1e-9, 1e-12]\nfor tol in tolerances:\n    result, error_est, n_final, iterations = adaptive_trapezoidal(f_test, a, b, tol=tol)\n    actual_error = abs(result - exact_ref)\n    print(f\"Tolerance: {tol:.0e}\")\n    print(f\"  Result: {result:.12f}\")\n    print(f\"  Actual error: {actual_error:.2e}\")\n    print(f\"  Subintervals: {n_final}, Iterations: {iterations}\")\n    print()","kernel":"python3","output":{"0":{"name":"stdout","text":"Adaptive Trapezoidal Rule: f(x) = exp(-x²) on [0, 2]\nReference value (scipy.quad): 0.8820813908\n------------------------------------------------------------\nTolerance: 1e-03\n  Result: 0.881703791332\n  Actual error: 3.78e-04\n  Subintervals: 8, Iterations: 3\n\nTolerance: 1e-06\n  Result: 0.882081018134\n  Actual error: 3.73e-07\n  Subintervals: 256, Iterations: 8\n\nTolerance: 1e-09\n  Result: 0.882081390399\n  Actual error: 3.64e-10\n  Subintervals: 8192, Iterations: 13\n\nTolerance: 1e-12\n  Result: 0.882081390762\n  Actual error: 3.55e-13\n  Subintervals: 262144, Iterations: 18\n\n"}},"pos":15,"start":1763844047455,"state":"done","type":"cell"}
{"cell_type":"code","end":1763844050520,"exec_count":11,"id":"7f5bf1","input":"# Create a comprehensive summary figure\nfig = plt.figure(figsize=(14, 10))\n\n# Define test function\nf = lambda x: np.sin(x) + 0.5 * np.sin(3*x)\na, b = 0, 2*np.pi\nexact_value, _ = integrate.quad(f, a, b)\n\n# Subplot 1: Geometric interpretation with few trapezoids\nax1 = fig.add_subplot(2, 2, 1)\nn = 6\nx_fine = np.linspace(a, b, 1000)\ny_fine = f(x_fine)\nx_trap = np.linspace(a, b, n + 1)\ny_trap = f(x_trap)\n\nax1.plot(x_fine, y_fine, 'b-', linewidth=2, label='$f(x) = \\sin(x) + 0.5\\sin(3x)$')\nfor i in range(n):\n    xs = [x_trap[i], x_trap[i], x_trap[i+1], x_trap[i+1]]\n    ys = [0, y_trap[i], y_trap[i+1], 0]\n    ax1.fill(xs, ys, alpha=0.3, color='orange', edgecolor='red', linewidth=1)\nax1.plot(x_trap, y_trap, 'ro', markersize=6)\nax1.axhline(y=0, color='k', linewidth=0.5)\nax1.set_xlabel('x')\nax1.set_ylabel('f(x)')\nax1.set_title(f'n = {n} trapezoids, Approx = {trapezoidal_rule(f, a, b, n):.4f}')\nax1.legend(loc='upper right', fontsize=9)\n\n# Subplot 2: More trapezoids\nax2 = fig.add_subplot(2, 2, 2)\nn = 20\nx_trap = np.linspace(a, b, n + 1)\ny_trap = f(x_trap)\n\nax2.plot(x_fine, y_fine, 'b-', linewidth=2)\nfor i in range(n):\n    xs = [x_trap[i], x_trap[i], x_trap[i+1], x_trap[i+1]]\n    ys = [0, y_trap[i], y_trap[i+1], 0]\n    ax2.fill(xs, ys, alpha=0.3, color='green', edgecolor='darkgreen', linewidth=0.5)\nax2.plot(x_trap, y_trap, 'go', markersize=4)\nax2.axhline(y=0, color='k', linewidth=0.5)\nax2.set_xlabel('x')\nax2.set_ylabel('f(x)')\nax2.set_title(f'n = {n} trapezoids, Approx = {trapezoidal_rule(f, a, b, n):.6f}')\n\n# Subplot 3: Convergence plot\nax3 = fig.add_subplot(2, 2, 3)\nn_range = 2**np.arange(1, 12)\nerrors = [abs(exact_value - trapezoidal_rule(f, a, b, n)) for n in n_range]\n\nax3.loglog(n_range, errors, 'bo-', linewidth=2, markersize=8, label='Trapezoidal')\n# O(n^-2) reference\nref_line = errors[0] * (n_range[0] / n_range)**2\nax3.loglog(n_range, ref_line, 'r--', linewidth=2, label='$O(n^{-2})$')\nax3.set_xlabel('Number of subintervals $n$')\nax3.set_ylabel('Absolute Error')\nax3.set_title('Convergence Analysis')\nax3.legend()\nax3.grid(True, which='both', alpha=0.3)\n\n# Subplot 4: Approximation vs n\nax4 = fig.add_subplot(2, 2, 4)\nn_vals = np.arange(2, 51)\napprox_vals = [trapezoidal_rule(f, a, b, n) for n in n_vals]\n\nax4.plot(n_vals, approx_vals, 'g-', linewidth=2, label='Trapezoidal Approximation')\nax4.axhline(y=exact_value, color='r', linestyle='--', linewidth=2, \n            label=f'Exact = {exact_value:.6f}')\nax4.fill_between(n_vals, exact_value - 0.01, exact_value + 0.01, \n                  alpha=0.2, color='red', label='±0.01 band')\nax4.set_xlabel('Number of subintervals $n$')\nax4.set_ylabel('Integral Value')\nax4.set_title('Convergence to Exact Value')\nax4.legend(loc='upper right')\nax4.grid(True, alpha=0.3)\n\nplt.suptitle('The Trapezoidal Rule for Numerical Integration', fontsize=16, y=1.02)\nplt.tight_layout()\n\n# Save the figure\nplt.savefig('plot.png', dpi=150, bbox_inches='tight')\nplt.show()\n\nprint(f\"\\nFigure saved to 'plot.png'\")\nprint(f\"Exact integral value: {exact_value:.10f}\")","kernel":"python3","output":{"0":{"data":{"image/png":"fc98abc8e1c6f5b2195211fe0b9bef64f2d27dd5","text/plain":"<Figure size 1400x1000 with 4 Axes>"},"metadata":{"image/png":{"height":1019,"width":1385}}},"1":{"name":"stdout","text":"\nFigure saved to 'plot.png'\nExact integral value: 0.0000000000\n"}},"pos":17,"start":1763844047594,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"03c121","input":"## Visualization: Geometric Interpretation\n\nThe following visualization demonstrates how the trapezoidal rule approximates the integral by fitting trapezoids under the curve:","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"1201d4","input":"## Example 1: Integrating a Simple Polynomial\n\nLet's test our implementation with $f(x) = x^3$ on $[0, 2]$.\n\nThe analytical solution is:\n\n$$\\int_0^2 x^3 \\, dx = \\left[\\frac{x^4}{4}\\right]_0^2 = \\frac{16}{4} = 4$$","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"4bea25","input":"## Example 2: Integrating a Transcendental Function\n\nConsider $f(x) = e^{-x^2}$ (Gaussian function) on $[0, 1]$.\n\nThis integral has no closed-form solution in terms of elementary functions, but is related to the error function:\n\n$$\\int_0^1 e^{-x^2} \\, dx = \\frac{\\sqrt{\\pi}}{2} \\cdot \\text{erf}(1) \\approx 0.7468241328$$","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"5869ac","input":"## Adaptive Trapezoidal Rule with Error Estimation\n\nIn practice, we often want to achieve a specified tolerance automatically. We can implement an adaptive version that doubles the number of points until the desired accuracy is reached:","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"6a9d12","input":"# Numerical Integration: The Trapezoidal Rule\n\n## Introduction\n\nThe **Trapezoidal Rule** is a fundamental numerical integration technique used to approximate the definite integral of a function. It belongs to the family of Newton-Cotes formulas and provides a simple yet effective method for computing integrals when analytical solutions are difficult or impossible to obtain.\n\n## Mathematical Foundation\n\n### The Definite Integral\n\nFor a continuous function $f(x)$ on the interval $[a, b]$, the definite integral is defined as:\n\n$$I = \\int_a^b f(x) \\, dx$$\n\nThis integral represents the signed area under the curve $f(x)$ between $x = a$ and $x = b$.\n\n### Derivation of the Trapezoidal Rule\n\nThe basic idea is to approximate the area under the curve by dividing the interval $[a, b]$ into $n$ subintervals of equal width $h$, where:\n\n$$h = \\frac{b - a}{n}$$\n\nThe subinterval endpoints are:\n\n$$x_i = a + ih, \\quad i = 0, 1, 2, \\ldots, n$$\n\nWithin each subinterval $[x_i, x_{i+1}]$, we approximate the function by a linear interpolant (a straight line connecting the endpoints). The area of each trapezoid is:\n\n$$A_i = \\frac{h}{2}\\left[f(x_i) + f(x_{i+1})\\right]$$\n\n### Composite Trapezoidal Rule\n\nSumming over all subintervals, we obtain the **Composite Trapezoidal Rule**:\n\n$$\\int_a^b f(x) \\, dx \\approx \\frac{h}{2}\\left[f(x_0) + 2\\sum_{i=1}^{n-1} f(x_i) + f(x_n)\\right]$$\n\nOr equivalently:\n\n$$\\int_a^b f(x) \\, dx \\approx h\\left[\\frac{f(a) + f(b)}{2} + \\sum_{i=1}^{n-1} f(x_i)\\right]$$\n\n### Error Analysis\n\nThe truncation error for the composite trapezoidal rule is:\n\n$$E_T = -\\frac{(b-a)h^2}{12}f''(\\xi)$$\n\nwhere $\\xi \\in [a, b]$. This shows that the error is $O(h^2)$, meaning the method has **second-order accuracy**. Halving the step size reduces the error by approximately a factor of 4.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"8cde74","input":"## Implementation\n\n### Basic Trapezoidal Rule Function\n\nWe implement the composite trapezoidal rule as a Python function:","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"af6935","input":"## Final Visualization: Summary Plot\n\nWe create a comprehensive summary figure showing the trapezoidal rule in action:","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"dd5037","input":"## Conclusion\n\nThe **Trapezoidal Rule** is a foundational numerical integration method with the following key properties:\n\n1. **Simplicity**: Easy to implement and understand geometrically\n2. **Second-order accuracy**: Error scales as $O(h^2)$\n3. **Stability**: Well-behaved for smooth functions\n4. **Versatility**: Applicable to any continuous function\n\n### Limitations\n\n- Linear approximation may be poor for rapidly varying functions\n- Requires many subintervals for high accuracy\n- Higher-order methods (Simpson's rule, Gaussian quadrature) often more efficient\n\n### When to Use\n\n- Quick estimates of integrals\n- Smooth, well-behaved functions\n- As a building block for more sophisticated adaptive methods\n- When simplicity is preferred over optimal efficiency\n\nThe trapezoidal rule remains a cornerstone of numerical analysis and serves as an excellent introduction to the broader field of numerical integration techniques.","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"de3d65","input":"## Comparison with Analytical Solution\n\nLet's create a comprehensive comparison showing how the approximation converges to the exact value as we increase the number of subintervals:","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"ed1049","input":"## Convergence Analysis\n\nWe now demonstrate the $O(h^2)$ convergence rate by plotting the error vs. the number of subintervals on a log-log scale:","pos":10,"type":"cell"}
{"id":0,"time":1763844034805,"type":"user"}
{"last_load":1763844035214,"type":"file"}