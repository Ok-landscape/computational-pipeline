{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-ca2193d8-d1f0-445a-a9eb-a878291d942b.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1763840107226,"last_ipynb_save":1763840119471,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1763840107256,"exec_count":3,"id":"f8e06e","input":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML\n\n# Set up plotting style\nplt.rcParams['figure.figsize'] = [12, 8]\nplt.rcParams['font.size'] = 12\nplt.rcParams['lines.linewidth'] = 2","kernel":"python3","pos":1,"start":1763840107250,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840107267,"exec_count":4,"id":"f5c877","input":"def flux(u):\n    \"\"\"Burgers flux function f(u) = u^2/2\"\"\"\n    return 0.5 * u**2\n\ndef godunov_flux(u_left, u_right):\n    \"\"\"\n    Godunov numerical flux for Burgers' equation.\n    Uses exact Riemann solver.\n    \"\"\"\n    if u_left >= u_right:\n        # Shock wave\n        if u_left + u_right >= 0:\n            return flux(u_left)\n        else:\n            return flux(u_right)\n    else:\n        # Rarefaction wave\n        if u_left >= 0:\n            return flux(u_left)\n        elif u_right <= 0:\n            return flux(u_right)\n        else:\n            return 0.0  # Sonic point\n\ndef lax_friedrichs(u, dt, dx):\n    \"\"\"Lax-Friedrichs scheme for Burgers' equation.\"\"\"\n    n = len(u)\n    u_new = np.zeros_like(u)\n    \n    for j in range(1, n-1):\n        u_new[j] = 0.5 * (u[j+1] + u[j-1]) - (dt / (2*dx)) * (flux(u[j+1]) - flux(u[j-1]))\n    \n    # Boundary conditions (outflow)\n    u_new[0] = u_new[1]\n    u_new[-1] = u_new[-2]\n    \n    return u_new\n\ndef godunov_scheme(u, dt, dx):\n    \"\"\"Godunov scheme for Burgers' equation.\"\"\"\n    n = len(u)\n    u_new = np.zeros_like(u)\n    \n    # Compute numerical fluxes at cell interfaces\n    f_half = np.zeros(n+1)\n    for j in range(n-1):\n        f_half[j+1] = godunov_flux(u[j], u[j+1])\n    \n    # Update interior cells\n    for j in range(1, n-1):\n        u_new[j] = u[j] - (dt/dx) * (f_half[j+1] - f_half[j])\n    \n    # Boundary conditions\n    u_new[0] = u_new[1]\n    u_new[-1] = u_new[-2]\n    \n    return u_new","kernel":"python3","pos":3,"start":1763840107264,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840107281,"exec_count":5,"id":"bd1687","input":"# Domain and grid parameters\nx_min, x_max = -1.0, 1.0\nnx = 400\ndx = (x_max - x_min) / (nx - 1)\nx = np.linspace(x_min, x_max, nx)\n\n# Time parameters\nt_final = 0.5\ncfl = 0.5  # CFL number for stability\n\n# Initial condition: sine wave\nu0 = np.sin(np.pi * x)\n\n# Theoretical breaking time\nt_break = 1.0 / np.pi\nprint(f\"Theoretical breaking time: t_b = 1/π ≈ {t_break:.4f}\")\nprint(f\"Simulation end time: t = {t_final}\")\nprint(f\"Number of grid points: {nx}\")\nprint(f\"Grid spacing: Δx = {dx:.6f}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Theoretical breaking time: t_b = 1/π ≈ 0.3183\nSimulation end time: t = 0.5\nNumber of grid points: 400\nGrid spacing: Δx = 0.005013\n"}},"pos":5,"start":1763840107275,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840107399,"exec_count":6,"id":"6247cc","input":"def solve_burgers(u0, x, t_final, cfl, scheme='godunov'):\n    \"\"\"\n    Solve Burgers' equation with given initial condition.\n    \n    Parameters:\n    -----------\n    u0 : array\n        Initial condition\n    x : array\n        Spatial grid\n    t_final : float\n        Final simulation time\n    cfl : float\n        CFL number\n    scheme : str\n        'godunov' or 'lax_friedrichs'\n    \n    Returns:\n    --------\n    times : list\n        Time values\n    solutions : list\n        Solution arrays at each time\n    \"\"\"\n    dx = x[1] - x[0]\n    u = u0.copy()\n    t = 0.0\n    \n    times = [0.0]\n    solutions = [u0.copy()]\n    \n    # Select scheme\n    if scheme == 'godunov':\n        update = godunov_scheme\n    else:\n        update = lax_friedrichs\n    \n    while t < t_final:\n        # Adaptive time step based on CFL condition\n        u_max = np.max(np.abs(u))\n        if u_max > 1e-10:\n            dt = cfl * dx / u_max\n        else:\n            dt = cfl * dx\n        \n        # Don't exceed final time\n        if t + dt > t_final:\n            dt = t_final - t\n        \n        # Update solution\n        u = update(u, dt, dx)\n        t += dt\n        \n        # Store solution at regular intervals\n        if len(times) < 100 or t >= t_final:\n            times.append(t)\n            solutions.append(u.copy())\n    \n    return times, solutions\n\n# Solve with Godunov scheme\ntimes, solutions = solve_burgers(u0, x, t_final, cfl, scheme='godunov')\nprint(f\"Simulation completed with {len(times)} time steps\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Simulation completed with 101 time steps\n"}},"pos":6,"start":1763840107349,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840109897,"exec_count":7,"id":"a8ed6e","input":"# Select time instances for plotting\nplot_times = [0.0, 0.1, 0.2, t_break, 0.4, t_final]\n\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\naxes = axes.flatten()\n\nfor idx, t_plot in enumerate(plot_times):\n    # Find closest time in solution\n    time_idx = np.argmin(np.abs(np.array(times) - t_plot))\n    u_plot = solutions[time_idx]\n    actual_time = times[time_idx]\n    \n    ax = axes[idx]\n    ax.plot(x, u_plot, 'b-', linewidth=2)\n    ax.plot(x, u0, 'k--', alpha=0.3, label='Initial')\n    \n    # Mark shock region if past breaking time\n    if actual_time > t_break:\n        ax.axvline(x=0, color='r', linestyle=':', alpha=0.5, label='Shock location')\n    \n    ax.set_xlabel('$x$')\n    ax.set_ylabel('$u(x, t)$')\n    ax.set_title(f'$t = {actual_time:.3f}$' + \n                 (' (breaking time)' if abs(actual_time - t_break) < 0.02 else ''))\n    ax.set_xlim([x_min, x_max])\n    ax.set_ylim([-1.5, 1.5])\n    ax.grid(True, alpha=0.3)\n    ax.legend(loc='upper right', fontsize=8)\n\nplt.suptitle(\"Burgers' Equation: Shock Wave Formation from Sinusoidal Initial Data\", \n             fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.savefig('plot.png', dpi=150, bbox_inches='tight')\nplt.show()\n\nprint(\"\\nPlot saved to 'plot.png'\")","kernel":"python3","output":{"0":{"data":{"image/png":"d6a2961bbf502e3bb2202c8e7c9c53702c84b5fd","text/plain":"<Figure size 1500x1000 with 6 Axes>"},"metadata":{"image/png":{"height":979,"width":1481}}},"1":{"name":"stdout","text":"\nPlot saved to 'plot.png'\n"}},"pos":8,"start":1763840107428,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840110870,"exec_count":8,"id":"914052","input":"# Plot characteristic curves\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# Initial positions for characteristics\nx0_chars = np.linspace(-0.9, 0.9, 30)\nt_char = np.linspace(0, t_final, 100)\n\nfor x0 in x0_chars:\n    u0_char = np.sin(np.pi * x0)  # Initial velocity at this point\n    x_char = x0 + u0_char * t_char  # Characteristic line\n    \n    # Color based on initial velocity\n    color = plt.cm.coolwarm((u0_char + 1) / 2)\n    ax.plot(x_char, t_char, color=color, alpha=0.7, linewidth=1)\n\n# Mark breaking time\nax.axhline(y=t_break, color='k', linestyle='--', linewidth=2, label=f'Breaking time $t_b = 1/\\\\pi$')\n\nax.set_xlabel('$x$', fontsize=12)\nax.set_ylabel('$t$', fontsize=12)\nax.set_title('Characteristic Curves for Burgers\\' Equation', fontsize=14)\nax.set_xlim([-2, 2])\nax.set_ylim([0, t_final])\nax.legend(loc='upper right')\nax.grid(True, alpha=0.3)\n\n# Add colorbar\nsm = plt.cm.ScalarMappable(cmap=plt.cm.coolwarm, norm=plt.Normalize(-1, 1))\nsm.set_array([])\ncbar = plt.colorbar(sm, ax=ax)\ncbar.set_label('Initial velocity $u_0$', fontsize=10)\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"data":{"image/png":"3a02a2e1a27a1d8965579f1265afc15e2550ac56","text/plain":"<Figure size 1000x800 with 2 Axes>"},"metadata":{"image/png":{"height":781,"width":964}}}},"pos":10,"start":1763840109908,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840115961,"exec_count":9,"id":"932c99","input":"def solve_viscous_burgers(u0, x, t_final, nu, dt_factor=0.4):\n    \"\"\"\n    Solve viscous Burgers' equation using FTCS for diffusion\n    and upwind for advection.\n    \"\"\"\n    dx = x[1] - x[0]\n    u = u0.copy()\n    t = 0.0\n    \n    # Stability constraint for viscous term\n    dt_visc = dt_factor * dx**2 / (2 * nu) if nu > 0 else np.inf\n    \n    while t < t_final:\n        # CFL for advection\n        u_max = np.max(np.abs(u))\n        dt_adv = dt_factor * dx / u_max if u_max > 1e-10 else dt_factor * dx\n        \n        # Use minimum for stability\n        dt = min(dt_adv, dt_visc)\n        if t + dt > t_final:\n            dt = t_final - t\n        \n        # Godunov for advection + central difference for diffusion\n        u_new = godunov_scheme(u, dt, dx)\n        \n        # Add viscous term\n        if nu > 0:\n            for j in range(1, len(u)-1):\n                u_new[j] += nu * dt / dx**2 * (u[j+1] - 2*u[j] + u[j-1])\n        \n        u = u_new\n        t += dt\n    \n    return u\n\n# Compare solutions with different viscosities\nviscosities = [0.0, 0.005, 0.02, 0.05]\nt_compare = 0.4\n\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor nu in viscosities:\n    if nu == 0:\n        # Use inviscid solution\n        time_idx = np.argmin(np.abs(np.array(times) - t_compare))\n        u_final = solutions[time_idx]\n        label = f'$\\\\nu = 0$ (inviscid)'\n    else:\n        u_final = solve_viscous_burgers(u0, x, t_compare, nu)\n        label = f'$\\\\nu = {nu}$'\n    \n    ax.plot(x, u_final, linewidth=2, label=label)\n\nax.set_xlabel('$x$', fontsize=12)\nax.set_ylabel('$u(x, t)$', fontsize=12)\nax.set_title(f'Effect of Viscosity on Shock Structure at $t = {t_compare}$', fontsize=14)\nax.legend(loc='upper right')\nax.grid(True, alpha=0.3)\nax.set_xlim([x_min, x_max])\nax.set_ylim([-1.5, 1.5])\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"data":{"image/png":"b88aaf96868b5be5163f990d0dad11ea9f2af9d5","text/plain":"<Figure size 1000x600 with 1 Axes>"},"metadata":{"image/png":{"height":580,"width":981}}}},"pos":12,"start":1763840110889,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840116792,"exec_count":10,"id":"3d9edf","input":"def exact_riemann_solution(x, t, u_L, u_R):\n    \"\"\"\n    Exact solution to the Riemann problem for Burgers' equation.\n    \"\"\"\n    if t == 0:\n        return np.where(x < 0, u_L, u_R)\n    \n    u = np.zeros_like(x)\n    xi = x / t  # Similarity variable\n    \n    if u_L > u_R:\n        # Shock wave\n        s = 0.5 * (u_L + u_R)\n        u = np.where(xi < s, u_L, u_R)\n    else:\n        # Rarefaction wave\n        u = np.where(xi <= u_L, u_L, \n                     np.where(xi >= u_R, u_R, xi))\n    \n    return u\n\n# Set up Riemann problems\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Case 1: Shock wave (u_L > u_R)\nu_L, u_R = 1.0, 0.0\nx_riemann = np.linspace(-1, 1, 400)\n\nax = axes[0]\nfor t in [0.0, 0.2, 0.4, 0.6]:\n    u_exact = exact_riemann_solution(x_riemann, t, u_L, u_R)\n    ax.plot(x_riemann, u_exact, label=f'$t = {t}$', linewidth=2)\n\nax.set_xlabel('$x$', fontsize=12)\nax.set_ylabel('$u(x, t)$', fontsize=12)\nax.set_title(f'Shock Wave: $u_L = {u_L}$, $u_R = {u_R}$', fontsize=14)\nax.legend()\nax.grid(True, alpha=0.3)\nax.set_ylim([-0.2, 1.2])\n\n# Case 2: Rarefaction wave (u_L < u_R)\nu_L, u_R = -0.5, 1.0\n\nax = axes[1]\nfor t in [0.0, 0.2, 0.4, 0.6]:\n    u_exact = exact_riemann_solution(x_riemann, t, u_L, u_R)\n    ax.plot(x_riemann, u_exact, label=f'$t = {t}$', linewidth=2)\n\nax.set_xlabel('$x$', fontsize=12)\nax.set_ylabel('$u(x, t)$', fontsize=12)\nax.set_title(f'Rarefaction Wave: $u_L = {u_L}$, $u_R = {u_R}$', fontsize=14)\nax.legend()\nax.grid(True, alpha=0.3)\nax.set_ylim([-0.7, 1.2])\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"data":{"image/png":"5f7fc2e860b77b748a3300ae8efac2d0b479a047","text/plain":"<Figure size 1400x500 with 2 Axes>"},"metadata":{"image/png":{"height":480,"width":1381}}}},"pos":14,"start":1763840115977,"state":"done","type":"cell"}
{"cell_type":"code","end":1763840118122,"exec_count":11,"id":"cc04d7","input":"# Convergence study using Riemann problem with exact solution\nu_L, u_R = 1.0, 0.0\nt_test = 0.3\ngrid_sizes = [50, 100, 200, 400, 800]\nerrors = []\n\nfor nx in grid_sizes:\n    x_test = np.linspace(-1, 1, nx)\n    dx = x_test[1] - x_test[0]\n    \n    # Initial condition (step function)\n    u0_test = np.where(x_test < 0, u_L, u_R)\n    \n    # Solve numerically\n    _, sols = solve_burgers(u0_test, x_test, t_test, cfl=0.5, scheme='godunov')\n    u_num = sols[-1]\n    \n    # Exact solution\n    u_exact = exact_riemann_solution(x_test, t_test, u_L, u_R)\n    \n    # L1 error\n    error = np.sum(np.abs(u_num - u_exact)) * dx\n    errors.append(error)\n\n# Plot convergence\nfig, ax = plt.subplots(figsize=(8, 6))\n\ndx_values = [2.0/n for n in grid_sizes]\nax.loglog(dx_values, errors, 'bo-', linewidth=2, markersize=8, label='Godunov scheme')\n\n# Reference lines\ndx_ref = np.array(dx_values)\nax.loglog(dx_ref, 0.5*dx_ref, 'k--', label='$O(\\\\Delta x)$')\nax.loglog(dx_ref, 2*dx_ref**0.5, 'k:', label='$O(\\\\Delta x^{1/2})$')\n\nax.set_xlabel('$\\\\Delta x$', fontsize=12)\nax.set_ylabel('$L^1$ Error', fontsize=12)\nax.set_title('Convergence Study: Riemann Problem', fontsize=14)\nax.legend()\nax.grid(True, alpha=0.3)\n\n# Calculate convergence rate\nrates = [np.log(errors[i]/errors[i+1])/np.log(2) for i in range(len(errors)-1)]\nprint(\"Grid sizes:\", grid_sizes)\nprint(\"L1 errors:\", [f\"{e:.6f}\" for e in errors])\nprint(\"Convergence rates:\", [f\"{r:.2f}\" for r in rates])\n\nplt.tight_layout()\nplt.show()","kernel":"python3","output":{"0":{"name":"stdout","text":"Grid sizes: [50, 100, 200, 400, 800]\nL1 errors: ['0.021356', '0.012622', '0.004821', '0.002405', '0.001201']\nConvergence rates: ['0.76', '1.39', '1.00', '1.00']\n"},"1":{"data":{"image/png":"3e0eebbb9e041913b30d643dd66ef6196bbde72b","text/plain":"<Figure size 800x600 with 1 Axes>"},"metadata":{"image/png":{"height":579,"width":780}}}},"pos":16,"start":1763840116811,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"260b69","input":"## Numerical Methods\n\n### Finite Difference Schemes\n\nWe implement several numerical schemes to solve Burgers' equation:\n\n1. **Lax-Friedrichs scheme** (first-order, stable but diffusive):\n$$u_j^{n+1} = \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n) - \\frac{\\Delta t}{2\\Delta x}\\left(\\frac{(u_{j+1}^n)^2}{2} - \\frac{(u_{j-1}^n)^2}{2}\\right)$$\n\n2. **Lax-Wendroff scheme** (second-order):\n$$u_j^{n+1} = u_j^n - \\frac{\\Delta t}{2\\Delta x}(f_{j+1}^n - f_{j-1}^n) + \\frac{\\Delta t^2}{2\\Delta x^2}\\left(A_{j+1/2}(f_{j+1}^n - f_j^n) - A_{j-1/2}(f_j^n - f_{j-1}^n)\\right)$$\n\nwhere $f = u^2/2$ and $A = u$ is the flux Jacobian.\n\n3. **Godunov scheme** with exact Riemann solver (upwind, entropy-satisfying)","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"46146f","input":"## Visualization of Shock Formation\n\nWe plot the solution at several time instances to observe the steepening of the wave profile and eventual shock formation.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"47b1f5","input":"## Method of Characteristics Visualization\n\nTo better understand shock formation, we visualize the characteristic curves in the $x$-$t$ plane. The crossing of characteristics indicates shock formation.","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"58a050","input":"## Conclusions\n\nThis notebook demonstrated the fundamental properties of Burgers' equation and shock wave formation:\n\n1. **Nonlinear steepening**: The advection term $u\\partial_x u$ causes wave steepening, where faster-moving parts of the wave catch up with slower parts.\n\n2. **Shock formation**: For inviscid flow, smooth initial data develops discontinuities (shocks) in finite time. The breaking time can be predicted from the initial velocity gradient.\n\n3. **Entropy condition**: Physical shocks must satisfy the entropy condition $u_L > u_R$, ensuring that characteristics enter the shock from both sides.\n\n4. **Viscous smoothing**: Small viscosity regularizes shocks into thin transition layers, with the shock width scaling as $O(\\nu/|u_L - u_R|)$.\n\n5. **Numerical methods**: Conservative finite difference schemes like Godunov's method correctly capture shock waves without spurious oscillations.\n\nBurgers' equation serves as an essential stepping stone for understanding more complex hyperbolic conservation laws, including the Euler equations of gas dynamics and the shallow water equations.","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"5af327","input":"# Burgers' Equation and Shock Wave Formation\n\n## Introduction\n\nBurgers' equation is a fundamental partial differential equation that serves as a simplified model for fluid dynamics, nonlinear acoustics, gas dynamics, and traffic flow. It combines nonlinear wave propagation with diffusive effects, making it an ideal testbed for understanding shock wave formation.\n\n## Mathematical Formulation\n\n### The Viscous Burgers' Equation\n\nThe one-dimensional viscous Burgers' equation is given by:\n\n$$\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}$$\n\nwhere:\n- $u(x, t)$ is the velocity field\n- $\\nu \\geq 0$ is the kinematic viscosity (diffusion coefficient)\n- The term $u \\frac{\\partial u}{\\partial x}$ represents nonlinear advection\n- The term $\\nu \\frac{\\partial^2 u}{\\partial x^2}$ represents viscous diffusion\n\n### The Inviscid Burgers' Equation\n\nWhen $\\nu = 0$, we obtain the inviscid Burgers' equation:\n\n$$\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0$$\n\nThis can be written in conservative form as:\n\n$$\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{u^2}{2}\\right) = 0$$\n\n## Shock Wave Formation\n\n### Method of Characteristics\n\nFor the inviscid equation, the method of characteristics reveals that information propagates along curves where:\n\n$$\\frac{dx}{dt} = u$$\n\nAlong these characteristics, $u$ remains constant:\n\n$$\\frac{du}{dt} = 0$$\n\nThis means characteristics are straight lines: $x = x_0 + u_0 t$, where $u_0 = u(x_0, 0)$.\n\n### Breaking Time\n\nWhen characteristics cross, the solution becomes multi-valued, leading to shock formation. The breaking time $t_b$ is:\n\n$$t_b = \\frac{-1}{\\min\\left(\\frac{\\partial u_0}{\\partial x}\\right)}$$\n\nFor smooth initial conditions with a negative slope region, shocks form in finite time.\n\n### Rankine-Hugoniot Condition\n\nThe shock speed $s$ is determined by the Rankine-Hugoniot jump condition:\n\n$$s = \\frac{u_L + u_R}{2}$$\n\nwhere $u_L$ and $u_R$ are the states to the left and right of the shock.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"5fe2c9","input":"## Effect of Viscosity\n\nNow we compare the inviscid solution with viscous solutions to see how diffusion smooths the shock.","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"d6ec9e","input":"## Simulation: Shock Formation from Smooth Initial Data\n\nWe demonstrate shock formation using a sinusoidal initial condition:\n\n$$u_0(x) = \\sin(\\pi x)$$\n\non the domain $x \\in [-1, 1]$. The breaking time for this initial condition is:\n\n$$t_b = \\frac{1}{\\pi}$$\n\nsince $\\min(\\partial u_0/\\partial x) = -\\pi$.","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"d88289","input":"## Numerical Verification: Convergence Study\n\nWe verify our numerical scheme by performing a convergence study. For smooth solutions (before shock formation), we expect second-order accuracy; after shock formation, the scheme reduces to first-order at the shock.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"eeb50e","input":"## Riemann Problem: Shock and Rarefaction Waves\n\nThe Riemann problem is an initial value problem with piecewise constant initial data:\n\n$$u_0(x) = \\begin{cases} u_L & x < 0 \\\\ u_R & x > 0 \\end{cases}$$\n\nThe exact solution depends on the relationship between $u_L$ and $u_R$:\n\n1. **Shock wave** ($u_L > u_R$): A discontinuity traveling at speed $s = (u_L + u_R)/2$\n2. **Rarefaction wave** ($u_L < u_R$): A smooth fan connecting the two states","pos":13,"type":"cell"}
{"id":0,"time":1763840094389,"type":"user"}
{"last_load":1763840094689,"type":"file"}