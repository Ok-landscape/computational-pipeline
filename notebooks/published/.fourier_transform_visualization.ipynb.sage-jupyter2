{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-078e4b03-c99f-409a-a9d7-7d7be0511c44.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1763782033825,"last_ipynb_save":1763782060711,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbformat_minor":4,"version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1763782034446,"exec_count":3,"id":"ee2581","input":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, ifft\n\n# Set up plotting style\nplt.rcParams['figure.figsize'] = [12, 10]\nplt.rcParams['font.size'] = 10\nplt.rcParams['axes.grid'] = True\nplt.rcParams['grid.alpha'] = 0.3","kernel":"python3","pos":1,"start":1763782033845,"state":"done","type":"cell"}
{"cell_type":"code","end":1763782034461,"exec_count":4,"id":"fa2f46","input":"# Sampling parameters\nfs = 1000  # Sampling frequency (Hz)\nT = 1.0    # Total duration (seconds)\nN = int(fs * T)  # Number of samples\nt = np.linspace(0, T, N, endpoint=False)\n\n# Signal components\nf1, A1 = 5, 1.0    # 5 Hz component\nf2, A2 = 20, 0.5   # 20 Hz component\nf3, A3 = 50, 0.3   # 50 Hz component\n\n# Composite signal with noise\nnp.random.seed(42)\nnoise_amplitude = 0.2\nsignal = (A1 * np.sin(2 * np.pi * f1 * t) + \n          A2 * np.sin(2 * np.pi * f2 * t) + \n          A3 * np.sin(2 * np.pi * f3 * t) +\n          noise_amplitude * np.random.randn(N))\n\nprint(f\"Signal Parameters:\")\nprint(f\"  Sampling frequency: {fs} Hz\")\nprint(f\"  Duration: {T} s\")\nprint(f\"  Number of samples: {N}\")\nprint(f\"  Frequency resolution: {fs/N} Hz\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Signal Parameters:\n  Sampling frequency: 1000 Hz\n  Duration: 1.0 s\n  Number of samples: 1000\n  Frequency resolution: 1.0 Hz\n"}},"pos":3,"start":1763782034451,"state":"done","type":"cell"}
{"cell_type":"code","end":1763782034474,"exec_count":5,"id":"9550ed","input":"# Compute FFT\nfft_result = fft(signal)\nfrequencies = fftfreq(N, 1/fs)\n\n# Compute magnitude and phase\nmagnitude = np.abs(fft_result) / N  # Normalize by N\nphase = np.angle(fft_result)\n\n# For visualization, we only need positive frequencies\npositive_freq_mask = frequencies >= 0\nfreqs_positive = frequencies[positive_freq_mask]\nmagnitude_positive = 2 * magnitude[positive_freq_mask]  # Double for one-sided spectrum\nmagnitude_positive[0] /= 2  # DC component should not be doubled\n\n# Find dominant frequencies\npeak_indices = np.argsort(magnitude_positive)[-5:][::-1]\nprint(\"Dominant frequencies detected:\")\nfor idx in peak_indices:\n    if magnitude_positive[idx] > 0.05:  # Threshold to avoid noise peaks\n        print(f\"  {freqs_positive[idx]:.1f} Hz: amplitude = {magnitude_positive[idx]:.3f}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Dominant frequencies detected:\n  5.0 Hz: amplitude = 0.998\n  20.0 Hz: amplitude = 0.522\n  50.0 Hz: amplitude = 0.295\n"}},"pos":5,"start":1763782034470,"state":"done","type":"cell"}
{"cell_type":"code","end":1763782037224,"exec_count":6,"id":"7aa041","input":"# Create comprehensive visualization\nfig = plt.figure(figsize=(14, 12))\n\n# Panel 1: Time-domain signal\nax1 = fig.add_subplot(3, 2, 1)\nax1.plot(t * 1000, signal, 'b-', linewidth=0.5, alpha=0.8)\nax1.set_xlabel('Time (ms)')\nax1.set_ylabel('Amplitude')\nax1.set_title('Time-Domain Signal\\n$f(t) = \\\\sin(2\\\\pi \\\\cdot 5t) + 0.5\\\\sin(2\\\\pi \\\\cdot 20t) + 0.3\\\\sin(2\\\\pi \\\\cdot 50t) + \\\\eta(t)$')\nax1.set_xlim([0, 200])  # Show first 200 ms for clarity\n\n# Panel 2: Zoomed time-domain\nax2 = fig.add_subplot(3, 2, 2)\nax2.plot(t * 1000, signal, 'b-', linewidth=1)\nax2.set_xlabel('Time (ms)')\nax2.set_ylabel('Amplitude')\nax2.set_title('Time-Domain Signal (Zoomed)')\nax2.set_xlim([0, 50])  # Show first 50 ms\n\n# Panel 3: Magnitude spectrum (linear scale)\nax3 = fig.add_subplot(3, 2, 3)\nax3.stem(freqs_positive, magnitude_positive, linefmt='b-', markerfmt='bo', basefmt='k-')\nax3.set_xlabel('Frequency (Hz)')\nax3.set_ylabel('Magnitude')\nax3.set_title('Magnitude Spectrum $|\\\\hat{f}(\\\\omega)|$')\nax3.set_xlim([0, 100])\n# Annotate peaks\nfor freq, amp in [(f1, A1), (f2, A2), (f3, A3)]:\n    ax3.annotate(f'{freq} Hz', xy=(freq, amp), xytext=(freq+5, amp+0.1),\n                 arrowprops=dict(arrowstyle='->', color='red'),\n                 fontsize=9, color='red')\n\n# Panel 4: Magnitude spectrum (dB scale)\nax4 = fig.add_subplot(3, 2, 4)\nmagnitude_db = 20 * np.log10(magnitude_positive + 1e-10)  # Add small value to avoid log(0)\nax4.plot(freqs_positive, magnitude_db, 'b-', linewidth=0.8)\nax4.set_xlabel('Frequency (Hz)')\nax4.set_ylabel('Magnitude (dB)')\nax4.set_title('Magnitude Spectrum (Decibel Scale)')\nax4.set_xlim([0, 100])\nax4.set_ylim([-60, 10])\n\n# Panel 5: Phase spectrum\nax5 = fig.add_subplot(3, 2, 5)\nphase_positive = phase[positive_freq_mask]\n# Only show phase where magnitude is significant\nsignificant_mask = magnitude_positive > 0.05\nax5.scatter(freqs_positive[significant_mask], phase_positive[significant_mask], \n            c='purple', s=20, alpha=0.6)\nax5.set_xlabel('Frequency (Hz)')\nax5.set_ylabel('Phase (radians)')\nax5.set_title('Phase Spectrum $\\\\arg(\\\\hat{f}(\\\\omega))$')\nax5.set_xlim([0, 100])\nax5.set_ylim([-np.pi, np.pi])\nax5.axhline(y=0, color='k', linestyle='--', linewidth=0.5)\n\n# Panel 6: Power Spectral Density\nax6 = fig.add_subplot(3, 2, 6)\npsd = magnitude_positive ** 2\nax6.fill_between(freqs_positive, psd, alpha=0.4, color='green')\nax6.plot(freqs_positive, psd, 'g-', linewidth=1)\nax6.set_xlabel('Frequency (Hz)')\nax6.set_ylabel('Power')\nax6.set_title('Power Spectral Density $|\\\\hat{f}(\\\\omega)|^2$')\nax6.set_xlim([0, 100])\n\nplt.tight_layout()\nplt.savefig('plot.png', dpi=150, bbox_inches='tight')\nplt.show()\n\nprint(\"\\nVisualization saved to 'plot.png'\")","kernel":"python3","output":{"0":{"data":{"image/png":"0ec1f9dd0fa1ed17bff848e0a653b3971c1304ab","text/plain":"<Figure size 1400x1200 with 6 Axes>"},"metadata":{"image/png":{"height":1186,"width":1390}}},"1":{"name":"stdout","text":"\nVisualization saved to 'plot.png'\n"}},"pos":7,"start":1763782034485,"state":"done","type":"cell"}
{"cell_type":"code","end":1763782037237,"exec_count":7,"id":"da1460","input":"# Demonstrate filtering in frequency domain\ncutoff_freq = 30  # Hz\n\n# Create low-pass filter\nfilter_mask = np.abs(frequencies) <= cutoff_freq\nfiltered_fft = fft_result * filter_mask\n\n# Reconstruct signal\nfiltered_signal = np.real(ifft(filtered_fft))\n\n# Verify energy conservation (Parseval's theorem)\ntime_domain_energy = np.sum(signal ** 2)\nfreq_domain_energy = np.sum(np.abs(fft_result) ** 2) / N\n\nprint(f\"Energy Conservation (Parseval's Theorem):\")\nprint(f\"  Time-domain energy: {time_domain_energy:.4f}\")\nprint(f\"  Frequency-domain energy: {freq_domain_energy:.4f}\")\nprint(f\"  Relative error: {abs(time_domain_energy - freq_domain_energy)/time_domain_energy * 100:.4f}%\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Energy Conservation (Parseval's Theorem):\n  Time-domain energy: 715.3558\n  Frequency-domain energy: 715.3558\n  Relative error: 0.0000%\n"}},"pos":9,"start":1763782037232,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"056dc4","input":"## Conclusion\n\nThis notebook demonstrated the fundamental concepts of Fourier analysis:\n\n1. **Frequency Decomposition**: The FFT successfully identified the three sinusoidal components at 5 Hz, 20 Hz, and 50 Hz with their respective amplitudes.\n\n2. **Magnitude and Phase**: The complete frequency-domain representation includes both magnitude (amplitude) and phase information.\n\n3. **Power Spectral Density**: The PSD shows the distribution of signal power across frequencies.\n\n4. **Parseval's Theorem**: Energy is conserved between time and frequency domains, confirming the mathematical correctness of our transform.\n\nThe Fourier Transform remains one of the most powerful tools in signal processing, physics, and engineering, enabling analysis and manipulation of signals in ways that would be difficult or impossible in the time domain alone.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"5b4b26","input":"## Fourier Transform Computation\n\nThe Fast Fourier Transform (FFT) algorithm computes the DFT in $O(N \\log N)$ operations, making it practical for large datasets.\n\nThe magnitude spectrum $|X_k|$ represents the amplitude of each frequency component, while the phase spectrum $\\arg(X_k)$ represents the phase offset.","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"6f65a1","input":"# Fourier Transform Visualization\n\n## Theoretical Foundation\n\nThe Fourier Transform is a fundamental mathematical tool that decomposes a function of time (or space) into its constituent frequencies. It serves as a bridge between the time domain and frequency domain representations of signals.\n\n### Continuous Fourier Transform\n\nFor a continuous function $f(t)$, the Fourier Transform $\\hat{f}(\\omega)$ is defined as:\n\n$$\\hat{f}(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} \\, dt$$\n\nThe inverse transform recovers the original function:\n\n$$f(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\hat{f}(\\omega) e^{i\\omega t} \\, d\\omega$$\n\n### Discrete Fourier Transform (DFT)\n\nFor computational purposes, we use the Discrete Fourier Transform. Given a sequence of $N$ complex numbers $\\{x_n\\}_{n=0}^{N-1}$, the DFT produces another sequence $\\{X_k\\}_{k=0}^{N-1}$:\n\n$$X_k = \\sum_{n=0}^{N-1} x_n e^{-i 2\\pi k n / N}$$\n\n### Euler's Formula Connection\n\nThe complex exponential can be decomposed using Euler's formula:\n\n$$e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$$\n\nThis reveals that the Fourier Transform measures the correlation between the signal and sinusoids of various frequencies.\n\n### Key Properties\n\n1. **Linearity**: $\\mathcal{F}\\{af + bg\\} = a\\mathcal{F}\\{f\\} + b\\mathcal{F}\\{g\\}$\n\n2. **Time Shifting**: $\\mathcal{F}\\{f(t-t_0)\\} = e^{-i\\omega t_0}\\hat{f}(\\omega)$\n\n3. **Frequency Shifting**: $\\mathcal{F}\\{e^{i\\omega_0 t}f(t)\\} = \\hat{f}(\\omega - \\omega_0)$\n\n4. **Parseval's Theorem**: $\\int_{-\\infty}^{\\infty} |f(t)|^2 \\, dt = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} |\\hat{f}(\\omega)|^2 \\, d\\omega$","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"e69a53","input":"## Comprehensive Visualization\n\nWe will create a multi-panel figure showing:\n1. Time-domain signal\n2. Magnitude spectrum (frequency domain)\n3. Phase spectrum\n4. Spectrogram (time-frequency representation)","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"eedcf1","input":"## Signal Generation\n\nWe will construct a composite signal consisting of multiple sinusoidal components:\n\n$$f(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\sin(2\\pi f_2 t) + A_3 \\sin(2\\pi f_3 t) + \\eta(t)$$\n\nwhere $\\eta(t)$ represents additive Gaussian noise.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"f10960","input":"## Signal Reconstruction via Inverse FFT\n\nWe can demonstrate the reversibility of the Fourier Transform by filtering the signal in the frequency domain and reconstructing it.\n\n### Low-Pass Filtering\n\nA low-pass filter attenuates frequencies above a cutoff $f_c$:\n\n$$H(f) = \\begin{cases} 1 & |f| \\leq f_c \\\\ 0 & |f| > f_c \\end{cases}$$","pos":8,"type":"cell"}
{"id":0,"time":1763782030304,"type":"user"}
{"last_load":1763782030513,"type":"file"}