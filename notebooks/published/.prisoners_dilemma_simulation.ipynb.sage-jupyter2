{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-10a3d291-2def-406f-8bfe-137c8a421fbe.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1763853210557,"last_ipynb_save":1763853224846,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1763853210584,"exec_count":3,"id":"9062af","input":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom itertools import combinations\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Define the payoff matrix\n# Standard values: T=5, R=3, P=1, S=0\nT = 5  # Temptation to defect\nR = 3  # Reward for mutual cooperation\nP = 1  # Punishment for mutual defection\nS = 0  # Sucker's payoff\n\n# Payoff matrix: payoffs[my_action][opponent_action]\n# Actions: 0 = Defect, 1 = Cooperate\nPAYOFF_MATRIX = {\n    (1, 1): (R, R),  # Both cooperate\n    (1, 0): (S, T),  # I cooperate, opponent defects\n    (0, 1): (T, S),  # I defect, opponent cooperates\n    (0, 0): (P, P),  # Both defect\n}\n\nprint(\"Payoff Matrix (Player 1, Player 2):\")\nprint(f\"Both Cooperate (C,C): {PAYOFF_MATRIX[(1,1)]}\")\nprint(f\"P1 Cooperates, P2 Defects (C,D): {PAYOFF_MATRIX[(1,0)]}\")\nprint(f\"P1 Defects, P2 Cooperates (D,C): {PAYOFF_MATRIX[(0,1)]}\")\nprint(f\"Both Defect (D,D): {PAYOFF_MATRIX[(0,0)]}\")\nprint(f\"\\nVerification: T={T} > R={R} > P={P} > S={S}: {T > R > P > S}\")\nprint(f\"Verification: 2R={2*R} > T+S={T+S}: {2*R > T+S}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Payoff Matrix (Player 1, Player 2):\nBoth Cooperate (C,C): (3, 3)\nP1 Cooperates, P2 Defects (C,D): (0, 5)\nP1 Defects, P2 Cooperates (D,C): (5, 0)\nBoth Defect (D,D): (1, 1)\n\nVerification: T=5 > R=3 > P=1 > S=0: True\nVerification: 2R=6 > T+S=5: True\n"}},"pos":1,"start":1763853210572,"state":"done","type":"cell"}
{"cell_type":"code","end":1763853210599,"exec_count":4,"id":"f6043d","input":"class Strategy:\n    \"\"\"Base class for Prisoner's Dilemma strategies.\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.reset()\n    \n    def reset(self):\n        \"\"\"Reset the strategy for a new game.\"\"\"\n        self.my_history = []\n        self.opponent_history = []\n    \n    def move(self):\n        \"\"\"Return the next move: 1 for Cooperate, 0 for Defect.\"\"\"\n        raise NotImplementedError\n    \n    def update(self, my_move, opponent_move):\n        \"\"\"Update history after a round.\"\"\"\n        self.my_history.append(my_move)\n        self.opponent_history.append(opponent_move)\n\n\nclass AlwaysCooperate(Strategy):\n    def __init__(self):\n        super().__init__(\"Always Cooperate\")\n    \n    def move(self):\n        return 1\n\n\nclass AlwaysDefect(Strategy):\n    def __init__(self):\n        super().__init__(\"Always Defect\")\n    \n    def move(self):\n        return 0\n\n\nclass TitForTat(Strategy):\n    def __init__(self):\n        super().__init__(\"Tit-for-Tat\")\n    \n    def move(self):\n        if not self.opponent_history:\n            return 1  # Cooperate on first move\n        return self.opponent_history[-1]  # Copy opponent's last move\n\n\nclass Random(Strategy):\n    def __init__(self):\n        super().__init__(\"Random\")\n    \n    def move(self):\n        return np.random.randint(0, 2)\n\n\nclass GrimTrigger(Strategy):\n    \"\"\"Cooperates until opponent defects, then always defects.\"\"\"\n    def __init__(self):\n        super().__init__(\"Grim Trigger\")\n        self.triggered = False\n    \n    def reset(self):\n        super().reset()\n        self.triggered = False\n    \n    def move(self):\n        if self.triggered:\n            return 0\n        if self.opponent_history and 0 in self.opponent_history:\n            self.triggered = True\n            return 0\n        return 1\n\n\nclass Pavlov(Strategy):\n    \"\"\"Win-Stay, Lose-Shift: Repeat last move if rewarded (R or T), switch otherwise.\"\"\"\n    def __init__(self):\n        super().__init__(\"Pavlov\")\n    \n    def move(self):\n        if not self.my_history:\n            return 1  # Cooperate on first move\n        # If last outcome was good (both cooperated or I defected on cooperator)\n        last_my = self.my_history[-1]\n        last_opp = self.opponent_history[-1]\n        if (last_my == 1 and last_opp == 1) or (last_my == 0 and last_opp == 1):\n            return last_my  # Stay\n        else:\n            return 1 - last_my  # Switch\n\n\nprint(\"Strategies defined:\")\nstrategies = [AlwaysCooperate(), AlwaysDefect(), TitForTat(), \n              Random(), GrimTrigger(), Pavlov()]\nfor s in strategies:\n    print(f\"  - {s.name}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Strategies defined:\n  - Always Cooperate\n  - Always Defect\n  - Tit-for-Tat\n  - Random\n  - Grim Trigger\n  - Pavlov\n"}},"pos":2,"start":1763853210595,"state":"done","type":"cell"}
{"cell_type":"code","end":1763853210886,"exec_count":5,"id":"0d7fd6","input":"def play_match(strategy1, strategy2, num_rounds=100):\n    \"\"\"\n    Play a match between two strategies.\n    \n    Parameters:\n    -----------\n    strategy1, strategy2 : Strategy\n        The two competing strategies\n    num_rounds : int\n        Number of rounds to play\n    \n    Returns:\n    --------\n    tuple : (score1, score2, cooperation_rate1, cooperation_rate2)\n    \"\"\"\n    strategy1.reset()\n    strategy2.reset()\n    \n    score1, score2 = 0, 0\n    \n    for _ in range(num_rounds):\n        move1 = strategy1.move()\n        move2 = strategy2.move()\n        \n        payoff1, payoff2 = PAYOFF_MATRIX[(move1, move2)]\n        score1 += payoff1\n        score2 += payoff2\n        \n        strategy1.update(move1, move2)\n        strategy2.update(move2, move1)\n    \n    coop_rate1 = sum(strategy1.my_history) / num_rounds\n    coop_rate2 = sum(strategy2.my_history) / num_rounds\n    \n    return score1, score2, coop_rate1, coop_rate2\n\n\ndef run_tournament(strategies, num_rounds=100, num_repetitions=10):\n    \"\"\"\n    Run a round-robin tournament between all strategies.\n    \n    Parameters:\n    -----------\n    strategies : list\n        List of Strategy objects\n    num_rounds : int\n        Number of rounds per match\n    num_repetitions : int\n        Number of times to repeat each match (for statistical robustness)\n    \n    Returns:\n    --------\n    dict : Tournament results\n    \"\"\"\n    n = len(strategies)\n    total_scores = {s.name: 0 for s in strategies}\n    match_results = []\n    cooperation_rates = {s.name: [] for s in strategies}\n    \n    # Round-robin: each strategy plays against every other strategy\n    for i, s1 in enumerate(strategies):\n        for j, s2 in enumerate(strategies):\n            if i <= j:  # Include self-play\n                avg_score1, avg_score2 = 0, 0\n                avg_coop1, avg_coop2 = 0, 0\n                \n                for _ in range(num_repetitions):\n                    score1, score2, coop1, coop2 = play_match(s1, s2, num_rounds)\n                    avg_score1 += score1\n                    avg_score2 += score2\n                    avg_coop1 += coop1\n                    avg_coop2 += coop2\n                \n                avg_score1 /= num_repetitions\n                avg_score2 /= num_repetitions\n                avg_coop1 /= num_repetitions\n                avg_coop2 /= num_repetitions\n                \n                total_scores[s1.name] += avg_score1\n                cooperation_rates[s1.name].append(avg_coop1)\n                \n                if i != j:\n                    total_scores[s2.name] += avg_score2\n                    cooperation_rates[s2.name].append(avg_coop2)\n                \n                match_results.append({\n                    'player1': s1.name,\n                    'player2': s2.name,\n                    'score1': avg_score1,\n                    'score2': avg_score2,\n                    'coop1': avg_coop1,\n                    'coop2': avg_coop2\n                })\n    \n    # Calculate average cooperation rate\n    avg_cooperation = {name: np.mean(rates) for name, rates in cooperation_rates.items()}\n    \n    return {\n        'total_scores': total_scores,\n        'match_results': match_results,\n        'avg_cooperation': avg_cooperation\n    }\n\n\n# Run the tournament\nprint(\"Running tournament...\")\nresults = run_tournament(strategies, num_rounds=200, num_repetitions=50)\n\n# Display results\nprint(\"\\n\" + \"=\"*50)\nprint(\"TOURNAMENT RESULTS\")\nprint(\"=\"*50)\n\n# Sort by total score\nsorted_scores = sorted(results['total_scores'].items(), key=lambda x: x[1], reverse=True)\n\nprint(\"\\nFinal Rankings:\")\nprint(\"-\"*50)\nfor rank, (name, score) in enumerate(sorted_scores, 1):\n    coop_rate = results['avg_cooperation'][name]\n    print(f\"{rank}. {name:20s} Score: {score:8.1f}  Coop Rate: {coop_rate:.2%}\")","kernel":"python3","output":{"0":{"name":"stdout","text":"Running tournament...\n"},"1":{"name":"stdout","text":"\n==================================================\nTOURNAMENT RESULTS\n==================================================\n\nFinal Rankings:\n--------------------------------------------------\n1. Grim Trigger         Score:   3194.2  Coop Rate: 83.59%\n2. Tit-for-Tat          Score:   3049.8  Coop Rate: 91.85%\n3. Pavlov               Score:   2963.7  Coop Rate: 99.87%\n4. Always Defect        Score:   2807.4  Coop Rate: 0.00%\n5. Always Cooperate     Score:   2699.2  Coop Rate: 116.67%\n6. Random               Score:   2347.4  Coop Rate: 58.47%\n"}},"pos":3,"start":1763853210609,"state":"done","type":"cell"}
{"cell_type":"code","end":1763853212541,"exec_count":6,"id":"edc036","input":"# Create comprehensive visualization\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# Extract data for plotting\nnames = [name for name, _ in sorted_scores]\nscores = [score for _, score in sorted_scores]\ncoop_rates = [results['avg_cooperation'][name] for name in names]\n\n# Color palette\ncolors = plt.cm.viridis(np.linspace(0.2, 0.8, len(names)))\n\n# Plot 1: Total Scores Bar Chart\nax1 = axes[0, 0]\nbars = ax1.barh(names, scores, color=colors)\nax1.set_xlabel('Total Score', fontsize=12)\nax1.set_title('Tournament Results: Total Scores', fontsize=14, fontweight='bold')\nax1.invert_yaxis()\nfor bar, score in zip(bars, scores):\n    ax1.text(score + 20, bar.get_y() + bar.get_height()/2, \n             f'{score:.0f}', va='center', fontsize=10)\n\n# Plot 2: Cooperation Rates\nax2 = axes[0, 1]\nbars2 = ax2.barh(names, [r*100 for r in coop_rates], color=colors)\nax2.set_xlabel('Cooperation Rate (%)', fontsize=12)\nax2.set_title('Average Cooperation Rates', fontsize=14, fontweight='bold')\nax2.invert_yaxis()\nax2.axvline(x=50, color='red', linestyle='--', alpha=0.5, label='50% baseline')\nfor bar, rate in zip(bars2, coop_rates):\n    ax2.text(rate*100 + 2, bar.get_y() + bar.get_height()/2, \n             f'{rate:.1%}', va='center', fontsize=10)\n\n# Plot 3: Score vs Cooperation Scatter\nax3 = axes[1, 0]\nscatter = ax3.scatter(coop_rates, scores, c=range(len(names)), \n                      cmap='viridis', s=200, edgecolors='black', linewidth=1.5)\nfor i, name in enumerate(names):\n    ax3.annotate(name, (coop_rates[i], scores[i]), \n                 xytext=(5, 5), textcoords='offset points', fontsize=9)\nax3.set_xlabel('Cooperation Rate', fontsize=12)\nax3.set_ylabel('Total Score', fontsize=12)\nax3.set_title('Score vs. Cooperation Rate', fontsize=14, fontweight='bold')\nax3.grid(True, alpha=0.3)\n\n# Plot 4: Head-to-head heatmap\nax4 = axes[1, 1]\n\n# Create score matrix\nstrategy_names = [s.name for s in strategies]\nn = len(strategy_names)\nscore_matrix = np.zeros((n, n))\n\nfor result in results['match_results']:\n    i = strategy_names.index(result['player1'])\n    j = strategy_names.index(result['player2'])\n    score_matrix[i, j] = result['score1']\n    if i != j:\n        score_matrix[j, i] = result['score2']\n\nim = ax4.imshow(score_matrix, cmap='RdYlGn', aspect='auto')\nax4.set_xticks(range(n))\nax4.set_yticks(range(n))\nax4.set_xticklabels([s.name.replace(' ', '\\n') for s in strategies], fontsize=8)\nax4.set_yticklabels([s.name for s in strategies], fontsize=9)\nax4.set_xlabel('Opponent', fontsize=12)\nax4.set_ylabel('Player', fontsize=12)\nax4.set_title('Head-to-Head Scores\\n(Row Player Score)', fontsize=14, fontweight='bold')\n\n# Add colorbar\ncbar = plt.colorbar(im, ax=ax4)\ncbar.set_label('Score', fontsize=10)\n\n# Add score annotations to heatmap\nfor i in range(n):\n    for j in range(n):\n        text = ax4.text(j, i, f'{score_matrix[i, j]:.0f}',\n                       ha='center', va='center', fontsize=7,\n                       color='black' if 200 < score_matrix[i, j] < 500 else 'white')\n\nplt.tight_layout()\nplt.savefig('plot.png', dpi=150, bbox_inches='tight')\nplt.show()\n\nprint(\"\\nVisualization saved to 'plot.png'\")","kernel":"python3","output":{"0":{"data":{"image/png":"e214432e9ead01e51651a0b5c759cd9b9597b72e","text/plain":"<Figure size 1400x1000 with 5 Axes>"},"metadata":{"image/png":{"height":988,"width":1390}}},"1":{"name":"stdout","text":"\nVisualization saved to 'plot.png'\n"}},"pos":4,"start":1763853210903,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"adc664","input":"# Prisoner's Dilemma Simulation\n\n## Theoretical Background\n\nThe **Prisoner's Dilemma** is a fundamental concept in game theory that demonstrates why two rational individuals might not cooperate, even when it appears to be in their best interest. This paradox illustrates the tension between individual and collective rationality.\n\n### The Classic Formulation\n\nTwo players simultaneously choose to either **Cooperate (C)** or **Defect (D)**. The payoff matrix is typically represented as:\n\n$$\\begin{pmatrix} (R, R) & (S, T) \\\\ (T, S) & (P, P) \\end{pmatrix}$$\n\nwhere:\n- $R$ = Reward for mutual cooperation\n- $P$ = Punishment for mutual defection\n- $T$ = Temptation to defect (sucker's payoff for the other player)\n- $S$ = Sucker's payoff (when you cooperate but opponent defects)\n\nThe defining inequalities of the Prisoner's Dilemma are:\n\n$$T > R > P > S$$\n\n$$2R > T + S$$\n\nThe second condition ensures that mutual cooperation yields a higher total payoff than alternating between cooperation and defection.\n\n### Nash Equilibrium\n\nThe **Nash Equilibrium** occurs when neither player can improve their payoff by unilaterally changing their strategy. In the one-shot Prisoner's Dilemma, the unique Nash Equilibrium is **(D, D)** â€” mutual defection.\n\nFor player $i$, the expected payoff when both defect is:\n\n$$\\pi_i(D, D) = P$$\n\nThis is stable because:\n\n$$\\pi_i(D, D) = P > S = \\pi_i(C, D)$$\n\n### Iterated Prisoner's Dilemma\n\nWhen the game is repeated over multiple rounds, more complex strategies emerge. The probability of cooperation can be modeled as a function of past interactions.\n\nLet $p_t$ represent the probability of cooperation at round $t$. For strategy evolution:\n\n$$p_{t+1} = f(p_t, \\text{history})$$\n\n### Famous Strategies\n\n1. **Always Cooperate**: $p_t = 1 \\ \\forall t$\n2. **Always Defect**: $p_t = 0 \\ \\forall t$\n3. **Tit-for-Tat**: $a_t = a_{t-1}^{\\text{opponent}}$ (copy opponent's last move)\n4. **Random**: $p_t = 0.5 \\ \\forall t$\n\nIn this notebook, we simulate a round-robin tournament between these strategies and analyze their performance.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"c2e5e3","input":"## Analysis and Conclusions\n\n### Key Findings\n\nThe tournament results demonstrate several important principles from game theory:\n\n1. **Tit-for-Tat's Success**: This simple strategy typically performs well because it is:\n   - *Nice*: It starts by cooperating\n   - *Retaliatory*: It punishes defection immediately\n   - *Forgiving*: It returns to cooperation if the opponent does\n   - *Clear*: Its behavior is easy for opponents to understand and adapt to\n\n2. **The Cost of Unconditional Strategies**: \n   - *Always Cooperate* is exploited by defectors\n   - *Always Defect* cannot benefit from mutual cooperation\n\n3. **Cooperation Emerges**: In iterated games, cooperative strategies can outperform purely selfish ones through reciprocity.\n\n### Mathematical Insight\n\nThe average payoff per round for mutual cooperation is $R = 3$, while mutual defection yields $P = 1$. Over $n$ rounds:\n\n$$\\text{Payoff}_{\\text{cooperation}} = nR$$\n$$\\text{Payoff}_{\\text{defection}} = nP$$\n\nThe ratio of payoffs approaches:\n\n$$\\lim_{n \\to \\infty} \\frac{nR}{nP} = \\frac{R}{P} = 3$$\n\nThis shows that in the long run, mutual cooperation yields three times the payoff of mutual defection.\n\n### Real-World Applications\n\nThe Prisoner's Dilemma models many real-world scenarios:\n- International arms races and treaties\n- Environmental agreements (climate change mitigation)\n- Business competition and collaboration\n- Evolution of altruism in biology","pos":5,"type":"cell"}
{"id":0,"time":1763853201826,"type":"user"}
{"last_load":1763853202250,"type":"file"}